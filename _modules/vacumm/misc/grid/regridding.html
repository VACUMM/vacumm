
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>vacumm.misc.grid.regridding &#8212; VACUMM v3.6.2 documentation</title>
    <link rel="stylesheet" href="../../../../_static/vacumm.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
<!--<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../../index.html"><img src="../../../../static/logo_vacumm.png" border="0" alt="vacumm"/></a>
</div>-->

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Home</a>|&nbsp;</li>
        <li><a href="../../../../contents.html">Docs</a>|&nbsp;</li>
        <li><a href="../../../../user.faq.html">FAQ</a>|&nbsp;</li>
<!--         <li><a href="../../../../search.html">chercher</a>|&nbsp;</li> -->
        <li><a href="../../../../gallery.html">Gallery</a>|&nbsp;</li>
        <li><a href="https://forge.ifremer.fr/projects/vacumm">Forge</a>&nbsp; &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../vacumm.html" accesskey="U">vacumm</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/logo_vacumm.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for vacumm.misc.grid.regridding</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf8 -*-</span>
<span class="sd">&quot;&quot;&quot;Regridding utilities</span>

<span class="sd">.. seealso::</span>

<span class="sd">    Tutorials: :ref:`user.tut.misc.grid.regridding`</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright or Â© or Copr. Actimar/IFREMER (2010-2018)</span>
<span class="c1">#</span>
<span class="c1"># This software is a computer program whose purpose is to provide</span>
<span class="c1"># utilities for handling oceanographic and atmospheric data,</span>
<span class="c1"># with the ultimate goal of validating the MARS model from IFREMER.</span>
<span class="c1">#</span>
<span class="c1"># This software is governed by the CeCILL license under French law and</span>
<span class="c1"># abiding by the rules of distribution of free software.  You can  use,</span>
<span class="c1"># modify and/ or redistribute the software under the terms of the CeCILL</span>
<span class="c1"># license as circulated by CEA, CNRS and INRIA at the following URL</span>
<span class="c1"># &quot;http://www.cecill.info&quot;.</span>
<span class="c1">#</span>
<span class="c1"># As a counterpart to the access to the source code and  rights to copy,</span>
<span class="c1"># modify and redistribute granted by the license, users are provided only</span>
<span class="c1"># with a limited warranty  and the software&#39;s author,  the holder of the</span>
<span class="c1"># economic rights,  and the successive licensors  have only  limited</span>
<span class="c1"># liability.</span>
<span class="c1">#</span>
<span class="c1"># In this respect, the user&#39;s attention is drawn to the risks associated</span>
<span class="c1"># with loading,  using,  modifying and/or developing or reproducing the</span>
<span class="c1"># software by the user in light of its specific status of free software,</span>
<span class="c1"># that may mean  that it is complicated to manipulate,  and  that  also</span>
<span class="c1"># therefore means  that it is reserved for developers  and  experienced</span>
<span class="c1"># professionals having in-depth computer knowledge. Users are therefore</span>
<span class="c1"># encouraged to load and test the software&#39;s suitability as regards their</span>
<span class="c1"># requirements in conditions enabling the security of their systems and/or</span>
<span class="c1"># data to be ensured and,  more generally, to use and operate it in the</span>
<span class="c1"># same conditions as regards security.</span>
<span class="c1">#</span>
<span class="c1"># The fact that you are presently reading this means that you have had</span>
<span class="c1"># knowledge of the CeCILL license and that you accept its terms.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">gc</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">tempfile</span><span class="o">,</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">N</span><span class="o">,</span> <span class="nn">cdms2</span><span class="o">,</span>  <span class="nn">MV2</span><span class="o">,</span>  <span class="nn">regrid2</span>
<span class="kn">from</span> <span class="nn">cdms2.axis</span> <span class="k">import</span> <span class="n">TransientAxis</span>
<span class="kn">import</span> <span class="nn">cdtime</span>
<span class="kn">import</span> <span class="nn">genutil</span>
<span class="kn">from</span> <span class="nn">_geoslib</span> <span class="k">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>

<span class="kn">from</span> <span class="nn">...__init__</span> <span class="k">import</span> <span class="n">VACUMMError</span><span class="p">,</span> <span class="n">VACUMMWarning</span><span class="p">,</span> <span class="n">vacumm_warn</span><span class="p">,</span> <span class="n">vcwarn</span>
<span class="kn">from</span> <span class="nn">.kriging</span> <span class="k">import</span> <span class="n">krig</span> <span class="k">as</span> <span class="n">_krig_</span>
<span class="kn">from</span> <span class="nn">.misc</span> <span class="k">import</span> <span class="p">(</span><span class="n">axis1d_from_bounds</span><span class="p">,</span> <span class="n">get_xy</span><span class="p">,</span> <span class="n">isgrid</span><span class="p">,</span> <span class="n">t2uvgrids</span><span class="p">,</span> <span class="n">get_grid</span><span class="p">,</span>
    <span class="n">set_grid</span><span class="p">,</span> <span class="n">bounds1d</span><span class="p">,</span> <span class="n">bounds2d</span><span class="p">,</span> <span class="n">get_axis</span><span class="p">,</span>
    <span class="n">meshgrid</span><span class="p">,</span> <span class="n">create_grid</span><span class="p">,</span> <span class="n">resol</span><span class="p">,</span> <span class="n">meshcells</span><span class="p">,</span> <span class="n">curv2rect</span><span class="p">,</span> <span class="n">merge_axis_slice</span><span class="p">,</span>
    <span class="n">get_axis_slices</span><span class="p">,</span> <span class="n">get_axis</span><span class="p">,</span> <span class="n">transect_specs</span><span class="p">,</span> <span class="n">create_axes2d</span><span class="p">,</span>
    <span class="n">get_distances</span><span class="p">,</span>
    <span class="n">get_tri</span><span class="p">,</span> <span class="n">get_grid_type</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">axes</span> <span class="k">as</span> <span class="n">A</span>
<span class="kn">from</span> <span class="nn">...misc.misc</span> <span class="k">import</span> <span class="p">(</span><span class="n">cp_atts</span><span class="p">,</span> <span class="n">intersect</span><span class="p">,</span> <span class="n">kwfilter</span><span class="p">,</span> <span class="n">get_atts</span><span class="p">,</span> <span class="n">set_atts</span><span class="p">,</span> <span class="n">closeto</span><span class="p">,</span>
    <span class="n">splitidx</span><span class="p">,</span> <span class="n">MV2_concatenate</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">...misc.atime</span> <span class="k">import</span> <span class="n">are_same_units</span><span class="p">,</span> <span class="n">ch_units</span><span class="p">,</span> <span class="n">time_split</span><span class="p">,</span> <span class="n">lindates</span>
<span class="kn">from</span> <span class="nn">.basemap</span> <span class="k">import</span> <span class="n">get_proj</span>

<span class="n">MV</span><span class="o">=</span><span class="n">MV2</span>
<span class="n">cdms</span><span class="o">=</span><span class="n">cdms2</span>

<span class="c1"># Python functions</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fill1d&#39;</span><span class="p">,</span> <span class="s1">&#39;regular&#39;</span><span class="p">,</span> <span class="s1">&#39;regular_fill1d&#39;</span><span class="p">,</span> <span class="s1">&#39;cellave1d&#39;</span><span class="p">,</span> <span class="s1">&#39;spline_interp1d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;refine&#39;</span><span class="p">,</span> <span class="s1">&#39;GridData&#39;</span><span class="p">,</span> <span class="s1">&#39;griddata&#39;</span><span class="p">,</span> <span class="s1">&#39;cargen&#39;</span><span class="p">,</span> <span class="s1">&#39;fill2d&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid2d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;regrid1d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1d&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest1d&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic1d&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid2dold&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xy2grid&#39;</span><span class="p">,</span> <span class="s1">&#39;grid2xy&#39;</span><span class="p">,</span> <span class="s1">&#39;fill1d&#39;</span><span class="p">,</span> <span class="s1">&#39;GriddedMerger&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid_method&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cellave2d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp2d&#39;</span><span class="p">,</span> <span class="s1">&#39;xy2xy&#39;</span><span class="p">,</span> <span class="s1">&#39;shift1d&#39;</span><span class="p">,</span> <span class="s1">&#39;shift2d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shiftgrid&#39;</span><span class="p">,</span>  <span class="s1">&#39;transect&#39;</span><span class="p">,</span> <span class="s1">&#39;CDATRegridder&#39;</span><span class="p">,</span> <span class="s1">&#39;extend1d&#39;</span><span class="p">,</span> <span class="s1">&#39;extend2d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;extendgrid&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid2d_method_name&#39;</span><span class="p">,</span> <span class="s1">&#39;fill1d2&#39;</span><span class="p">,</span> <span class="s1">&#39;krig&#39;</span><span class="p">,</span> <span class="s1">&#39;CurvedInterpolator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;regrid1dold&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid2d_tool_name&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid2dnew&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid1d_method_name&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cellerr1d&#39;</span><span class="p">]</span>
<span class="n">__all__</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># Fortran functions</span>
<span class="n">_interp_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;interp1d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1dx&#39;</span><span class="p">,</span> <span class="s1">&#39;interp1dxx&#39;</span><span class="p">,</span>
    <span class="s1">&#39;remap1d&#39;</span><span class="p">,</span> <span class="s1">&#39;remap1dx&#39;</span><span class="p">,</span> <span class="s1">&#39;remap1dxx&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest2d&#39;</span><span class="p">,</span> <span class="s1">&#39;bilin&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mbilin2d&#39;</span><span class="p">,</span> <span class="s1">&#39;mixt2dx&#39;</span><span class="p">,</span> <span class="s1">&#39;cargen&#39;</span><span class="p">,</span> <span class="s1">&#39;extrap1d&#39;</span><span class="p">,</span> <span class="s1">&#39;curv2rel&#39;</span><span class="p">,</span>
    <span class="s1">&#39;nearest2dto1d&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest2dto1dc&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest2dto1dc_reduc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bilin2dto1d&#39;</span><span class="p">,</span> <span class="s1">&#39;bilin2dto1dc&#39;</span><span class="p">,</span> <span class="s1">&#39;bilin2dto1dc_reduc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dstwgt2dto1d&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt2dto1dc&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt2dto1dc_reduc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cellerr1d&#39;</span><span class="p">,</span> <span class="s1">&#39;cellerr1dx&#39;</span><span class="p">,</span> <span class="s1">&#39;cellerr1dxx&#39;</span><span class="p">,</span> <span class="s1">&#39;linear4dto1dxx&#39;</span><span class="p">,</span>
    <span class="s1">&#39;nearest4dto1dxx&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="c1"># Load fortran</span>
<span class="n">_interp_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> as _</span><span class="si">%s</span><span class="s1">_&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">ff</span><span class="p">,</span> <span class="n">ff</span><span class="p">)</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">_interp_funcs</span><span class="p">]</span>
<span class="n">_interp_funcs</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_interp_funcs</span><span class="p">)</span>
<span class="n">import_interp</span> <span class="o">=</span> <span class="s2">&quot;from _interp_ import </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_interp_funcs</span><span class="p">,</span> <span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">exec</span>  <span class="n">import_interp</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">e</span>
    <span class="nb">print</span> <span class="s1">&#39;Trying to build it...&#39;</span>
    <span class="kn">import</span> <span class="nn">subprocess</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;make&quot;</span><span class="p">]</span> <span class="c1"># Compilation of all vacumm extensions from the root of sources</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cwd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t build _interp_ for importation:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
    <span class="n">exec</span> <span class="n">import_interp</span>


<span class="c1"># Interpolation methods</span>
<span class="n">_griddata_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="s1">&#39;krig&#39;</span><span class="p">,</span> <span class="s1">&#39;carg&#39;</span><span class="p">]</span>
<span class="n">_cellave_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;conservative&#39;</span><span class="p">,</span> <span class="s1">&#39;remap&#39;</span><span class="p">,</span> <span class="s1">&#39;cellave&#39;</span><span class="p">,</span> <span class="s1">&#39;conserv&#39;</span><span class="p">]</span>
<span class="n">_cdat_methods</span> <span class="o">=</span> <span class="n">_cellave_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;patch&#39;</span><span class="p">]</span>
<span class="n">_regrid2d_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;mixt&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;bining&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_cdat_methods</span>
<span class="n">_interp1d_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="s1">&#39;hermit&#39;</span><span class="p">]</span>
<span class="n">_regrid1d_methods</span> <span class="o">=</span> <span class="n">_interp1d_methods</span><span class="o">+</span><span class="n">_cellave_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;cellerr&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="regrid1d_method_name"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid1d_method_name">[docs]</a><span class="k">def</span> <span class="nf">regrid1d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the method name and return its generic name&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;auto&#39;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cons&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;conserv&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cella&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;remap&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;cellave&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;celle&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;cellerr&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;lin&#39;</span> <span class="ow">in</span> <span class="n">method</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;linear&#39;</span>
<span class="c1">#    if method.startswith(&#39;bin&#39;): return &#39;bining&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;near&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;nearest&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cub&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;cubic&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;her&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;hermit&#39;</span>
    <span class="k">if</span> <span class="n">raiseerr</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Invalid regrid1d method. Please use for example one of these: &#39;</span><span class="o">+</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_regrid1d_methods</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span></div>


<div class="viewcode-block" id="regrid1dold"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid1dold">[docs]</a><span class="k">def</span> <span class="nf">regrid1dold</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_thres</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">extrap</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation along one axis</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array.</span>
<span class="sd">        - **axo**: Output cdms axis.</span>
<span class="sd">        - **method**:</span>

<span class="sd">            - ``&quot;nearest&quot;``: Nearest neighbor</span>
<span class="sd">            - ``&quot;linear&quot;``: Linear interpolation</span>
<span class="sd">            - ``&quot;cubic&quot;``: Cubic interpolation</span>
<span class="sd">            - ``&quot;cellave&quot;``: Cell averaging</span>
<span class="sd">            - ``&quot;conserv&quot;``: Conservative cel averaging (like ``cellave`` but with integral preserved)</span>

<span class="sd">        - **axis**, optional: Axis (int) on which to operate. If not specified, it is guessed from the</span>
<span class="sd">          input and output axis types, or set to ``0``.</span>
<span class="sd">        - **xmap**, optional: Integer or tuple that specify on which axes input axis is varying.</span>
<span class="sd">        - **xmapper**, optional: Array that specify values of input axis along axes specified by ``xmap``.</span>
<span class="sd">          It is an array of size ``(...,len(var.getAxis(xmap[-2])), len(var.getAxis(xmap[-1])), len(var.getAxis(axis))]``.</span>
<span class="sd">        - **mask_thres**, optional: Time steps when interpolated mask is greater than</span>
<span class="sd">          this value are masked.</span>
<span class="sd">        - **extrap**, optional: Extrapolate outside input grid when the &quot;nearest&quot; method</span>
<span class="sd">          is used:</span>

<span class="sd">            - ``0`` or ``False``: No extrapolation.</span>
<span class="sd">            - ``-1`` or ``&quot;min&quot;``, or ``&quot;bottom&quot;``, or ``&quot;lower&quot;``, or ``&quot;first&quot;``:</span>
<span class="sd">              Extrapolate toward first values of the axis.</span>
<span class="sd">            - ``1`` or ``&quot;max&quot;``, or ``&quot;top&quot;``, or ``&quot;upper&quot;``, or ``&quot;last&quot;``:</span>
<span class="sd">              Extrapolate toward last values of the axis.</span>
<span class="sd">            - ``2`` or ``&quot;both&quot;``: Extrapolate toward both first and last values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Cubic method, use &quot;linear&quot; interpolation when less than 4 valid points are available.</span>
<span class="sd">        Linear interpolation uses &quot;nearest&quot; interpolation when less than 2 points are</span>
<span class="sd">        available.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input specs</span>
    <span class="k">assert</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">),</span> <span class="s1">&#39;Works only with cdms variables&#39;</span>
    <span class="n">A</span><span class="o">.</span><span class="n">check_axes</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getOrder</span><span class="p">()</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
    <span class="n">missing_value</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">missing_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vari</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>
    <span class="n">missing_value</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>

    <span class="c1"># On which axis?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">axo</span><span class="p">):</span>
        <span class="n">axo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axo</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axo</span> <span class="o">=</span> <span class="n">cdms</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">axo</span><span class="p">)</span>
<span class="c1">#   if A.isaxis(axo): A.check_axis(axo)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="c1"># Guess it</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">axo</span><span class="p">):</span> <span class="c1"># From axis type</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">axis_type</span><span class="p">(</span><span class="n">axo</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>             <span class="c1"># From axis length</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Not found</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>      <span class="c1"># Last axis</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>                  <span class="c1"># Failed</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="s1">&#39;Wrong axis&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">regrid_method</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">axo</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">regrid1d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_cellave_methods</span><span class="p">:</span>
        <span class="n">conserv</span> <span class="o">=</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;conserv&#39;</span>
<span class="c1">#       conserv = method == &#39;conservative&#39;</span>
        <span class="n">method</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;cellerr&#39;</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_interp1d_methods</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">_interp1d_methods</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="c1"># Wrong method</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">method</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Wrong method&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">method</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Hermit is always better</span>
    <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">_interp1d_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">_interp1dx_</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">_remap1d_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">_remap1dx_</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">conserv</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">interp_func</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span>

    <span class="c1"># Extrapolation</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">extrap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">extrap</span><span class="p">))</span>

    <span class="c1"># Convert to numeric</span>
    <span class="n">varin</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>

    <span class="c1"># Translate axes</span>
    <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Simple case</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">varin</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">varin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">varin</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Extended case</span>

        <span class="c1"># Check xmap form</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xmap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">xmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmap</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xmap</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xmap</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">xmap</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xmap</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">xmap</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">xmap</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="s1">&#39;Wrong xmap axis&#39;</span>

        <span class="c1"># Roll axes</span>
        <span class="n">oldmap</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">varin</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">newmap</span> <span class="o">=</span> <span class="n">xmap</span><span class="o">+</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iax</span> <span class="ow">in</span> <span class="n">oldmap</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">iax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newmap</span><span class="p">:</span>
                <span class="n">newmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">iax</span><span class="p">]</span><span class="o">+</span><span class="n">newmap</span>
        <span class="k">if</span> <span class="n">oldmap</span> <span class="o">!=</span> <span class="n">newmap</span><span class="p">:</span>
<span class="c1">#           backmap = [oldmap.index(iax) for iax in newmap]</span>
            <span class="n">backmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">newmap</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iax</span><span class="p">)</span> <span class="k">for</span> <span class="n">iax</span> <span class="ow">in</span> <span class="n">oldmap</span><span class="p">]</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">varin</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">newmap</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">varin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backmap</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">varin</span>

        <span class="c1"># Size of extension block</span>
        <span class="n">nxb</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nxb</span><span class="p">,</span> <span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">nyi</span> <span class="o">=</span> <span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Axes content</span>
    <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Simple case</span>

        <span class="c1"># Input axis</span>
        <span class="n">axi</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Special case for time axis: must have same units !</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">axis_type</span><span class="p">(</span><span class="n">axo</span><span class="p">),</span> <span class="n">order</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axo</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="n">are_same_units</span><span class="p">(</span><span class="n">axi</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">units</span><span class="p">):</span>
            <span class="n">axi</span> <span class="o">=</span> <span class="n">ch_units</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># Extended case</span>

        <span class="n">axi</span> <span class="o">=</span> <span class="n">xmapper</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>


    <span class="c1"># Reshape var to get a 2D array</span>
    <span class="k">if</span> <span class="n">varis</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vari2d</span> <span class="o">=</span> <span class="n">varis</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varis</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">nyi</span><span class="p">,</span> <span class="n">nyi</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vari2d</span> <span class="o">=</span> <span class="n">varis</span>

    <span class="c1"># First guess</span>
    <span class="n">varo2d</span> <span class="o">=</span> <span class="n">regrid_func</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="n">axi</span><span class="p">[:],</span> <span class="n">axo</span><span class="p">[:],</span> <span class="n">missing_value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Mask</span>
    <span class="n">maski2d</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">==</span><span class="n">missing_value</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">and</span> <span class="n">N</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">maski2d</span><span class="p">):</span>

        <span class="c1"># Float mask</span>
        <span class="n">maski2df</span> <span class="o">=</span> <span class="n">maski2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">masko2d</span> <span class="o">=</span> <span class="n">regrid_func</span><span class="p">(</span><span class="n">maski2df</span><span class="p">,</span> <span class="n">axi</span><span class="p">[:],</span> <span class="n">axo</span><span class="p">[:],</span> <span class="mf">1.e20</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">masko2d</span><span class="p">[</span><span class="n">masko2d</span><span class="o">==</span><span class="mf">1.e20</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>

            <span class="c1"># Cell case: threshold</span>
            <span class="n">varo2d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masko2d</span><span class="o">&gt;</span><span class="n">mask_thres</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">,</span> <span class="n">varo2d</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Lower method</span>
            <span class="n">varolow</span> <span class="o">=</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="n">axi</span><span class="p">[:],</span> <span class="n">axo</span><span class="p">[:],</span> <span class="n">missing_value</span><span class="p">,</span>
                <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">method</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">extrap</span><span class="o">=</span><span class="n">extrap</span><span class="p">)</span>

            <span class="c1"># Cubic case: lower order again</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">masko2dc</span> <span class="o">=</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">maski2df</span><span class="p">,</span> <span class="n">axi</span><span class="p">[:],</span> <span class="n">axo</span><span class="p">[:],</span> <span class="mf">1.e20</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">masko2dc</span><span class="p">[</span><span class="n">masko2dc</span><span class="o">==</span><span class="mf">1.e20</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="n">varolowc</span> <span class="o">=</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="n">axi</span><span class="p">[:],</span> <span class="n">axo</span><span class="p">[:],</span> <span class="n">missing_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">varolow</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masko2dc</span><span class="o">!=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">varolowc</span><span class="p">,</span> <span class="n">varolow</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">masko2dc</span><span class="p">,</span> <span class="n">varolowc</span>

            <span class="c1"># Select between nearest and linear, or linear and cubic</span>
            <span class="n">varo2d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masko2d</span><span class="o">!=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">varolow</span><span class="p">,</span> <span class="n">varo2d</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">varolow</span>

        <span class="k">del</span> <span class="n">maski2df</span><span class="p">,</span> <span class="n">masko2d</span>

    <span class="c1"># Reshape back</span>
    <span class="k">if</span> <span class="n">varis</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">varos</span> <span class="o">=</span> <span class="n">varo2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axo</span><span class="p">),</span> <span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varo2d</span><span class="p">,</span> <span class="n">vari2d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varos</span> <span class="o">=</span> <span class="n">varo2d</span>
    <span class="k">del</span> <span class="n">varis</span>

    <span class="c1"># Retranslate axes back</span>
    <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">backmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">varon</span> <span class="o">=</span> <span class="n">varos</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">backmap</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varos</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">varon</span> <span class="o">=</span> <span class="n">varos</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varos</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varon</span> <span class="o">=</span> <span class="n">varos</span>

    <span class="c1"># Convert to cdms</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varon</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">axo</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setAxisList</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">varo</span></div>

<span class="k">def</span> <span class="nf">_subshape_</span><span class="p">(</span><span class="n">bigshape</span><span class="p">,</span> <span class="n">subshape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the index of a unique of occurence of subshape in bigshape or None</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **bigshape**: Tuple or big array.</span>
<span class="sd">        - **subshape**: Tuple or smaller array.</span>
<span class="sd">        - **axis**: Axis index of bigshape that is allowed to differ in subshape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bigshape</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">bigshape</span> <span class="o">=</span> <span class="n">bigshape</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">subshape</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">subshape</span> <span class="o">=</span> <span class="n">subshape</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">bigshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bigshape</span><span class="p">)</span>
    <span class="n">subshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">subshape</span><span class="p">)</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bigshape</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subshape</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nb</span><span class="o">&gt;=</span><span class="n">ns</span> <span class="c1"># TODO: make it more generic</span>
    <span class="n">istart</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="n">ns</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">subbigshape</span> <span class="o">=</span> <span class="n">bigshape</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">ns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">&gt;=</span><span class="n">i</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">i</span><span class="o">+</span><span class="n">ns</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">axis</span><span class="o">-</span><span class="n">i</span>
            <span class="n">subbigshape</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="n">subshape</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">subbigshape</span> <span class="o">==</span> <span class="n">subshape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">istart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="c1"># two solutions =&gt; no valid solution</span>
            <span class="n">istart</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">istart</span>

<span class="k">def</span> <span class="nf">_getiax_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess the index of the target axis of vari in the ax array&quot;&quot;&quot;</span>
    <span class="c1"># 1D case</span>
    <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># A unique sub-tuple</span>
    <span class="n">iax</span> <span class="o">=</span> <span class="n">_subshape_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">iax</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">-</span> <span class="n">iax</span>
        <span class="k">if</span> <span class="n">iax</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">iax</span>
        <span class="n">iax</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># A unique axis type</span>
    <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">axis_type</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">!=</span><span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">getOrder</span><span class="p">():</span>
            <span class="n">iax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">getOrder</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">iax</span>

<span class="k">def</span> <span class="nf">_syncshapes_</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">iaxo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resize two arrays to have the same shapes except when the second one is 1D</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **axi**: First numpy array.</span>
<span class="sd">        - **iaxi**: Index of pivot (target axis) in first array.</span>
<span class="sd">        - **axo**: Second numpy array.</span>
<span class="sd">        - **iaxo**: Index of pivot (target axis) in second array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Nothing to resize</span>
    <span class="k">if</span> <span class="n">axo</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">axi</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">iaxo</span>

    <span class="c1"># Pivot as a reference</span>
    <span class="n">nil</span> <span class="o">=</span> <span class="n">iaxi</span> <span class="c1"># left, first</span>
    <span class="n">nir</span> <span class="o">=</span> <span class="n">axi</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="n">iaxi</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># right, second</span>
    <span class="n">nol</span> <span class="o">=</span> <span class="n">iaxo</span> <span class="c1"># left, first</span>
    <span class="n">nor</span> <span class="o">=</span> <span class="n">axo</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="n">iaxo</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># right, second</span>

    <span class="c1"># Right adjusment</span>
    <span class="k">if</span> <span class="n">nir</span><span class="o">&gt;</span><span class="n">nor</span><span class="p">:</span> <span class="c1"># expand the second to the right</span>
        <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nir</span><span class="o">-</span><span class="n">nor</span><span class="p">):</span>
            <span class="n">axo</span> <span class="o">=</span> <span class="n">axo</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">axo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">axo</span><span class="p">,</span> <span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">iaxi</span><span class="o">+</span><span class="n">nor</span><span class="o">+</span><span class="n">ir</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">nor</span><span class="o">&gt;</span><span class="n">nir</span><span class="p">:</span> <span class="c1"># expand the first to the right</span>
        <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nor</span><span class="o">-</span><span class="n">nir</span><span class="p">):</span>
            <span class="n">axi</span> <span class="o">=</span> <span class="n">axi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">axi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">iaxo</span><span class="o">+</span><span class="n">nir</span><span class="o">+</span><span class="n">ir</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Left adjustment</span>
    <span class="k">if</span> <span class="n">nil</span><span class="o">&gt;</span><span class="n">nol</span><span class="p">:</span> <span class="c1"># expand the second to the left</span>
        <span class="n">axo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">axo</span><span class="p">,</span> <span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">nil</span><span class="o">-</span><span class="n">nol</span><span class="p">]</span><span class="o">+</span><span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">iaxo</span> <span class="o">+=</span> <span class="n">nil</span><span class="o">-</span><span class="n">nol</span>
    <span class="k">elif</span> <span class="n">nol</span><span class="o">&gt;</span><span class="n">nil</span><span class="p">:</span>
        <span class="n">axi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">nol</span><span class="o">-</span><span class="n">nil</span><span class="p">]</span><span class="o">+</span><span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">iaxi</span> <span class="o">+=</span> <span class="n">nol</span><span class="o">-</span><span class="n">nil</span>

    <span class="k">return</span> <span class="n">axi</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">iaxo</span>

<span class="k">def</span> <span class="nf">_toright_</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">iax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reform an array so the iax dim becomes the last</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **ar**: A numpy array.</span>
<span class="sd">        - **iax**: Index of the dim.</span>

<span class="sd">    :Return:</span>

<span class="sd">        ``newar,bakmap`` such as::</span>

<span class="sd">            newar.shape[-1] == ar.shape[iax]</span>
<span class="sd">            ar == newarr.translate(*bakmap)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">oldmap</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">newmap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">oldmap</span><span class="p">)</span>
    <span class="n">newmap</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iax</span><span class="p">)</span>
    <span class="n">newmap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iax</span><span class="p">)</span>
    <span class="n">bakmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">newmap</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iax</span><span class="p">)</span> <span class="k">for</span> <span class="n">iax</span> <span class="ow">in</span> <span class="n">oldmap</span><span class="p">]</span>
    <span class="n">newar</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">newmap</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newar</span><span class="p">,</span> <span class="n">bakmap</span>


<div class="viewcode-block" id="regrid1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid1d">[docs]</a><span class="k">def</span> <span class="nf">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iaxo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iaxi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">xmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_thres</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">extrap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">erri</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geterr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation along one axis</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array.</span>
<span class="sd">        - **axo**: Output cdms axis or array. It can be of any dimensions.</span>
<span class="sd">        - **method**:</span>

<span class="sd">            - ``&quot;nearest&quot;|0``: Nearest neighbor</span>
<span class="sd">            - ``&quot;linear&quot;|2``: Linear interpolation</span>
<span class="sd">            - ``&quot;cubic&quot;|2``: Cubic interpolation (not used, switched to ``3``)</span>
<span class="sd">            - ``&quot;hermit&quot;|3``: Cubic hermit interpolation</span>
<span class="sd">            - ``&quot;cellerr&quot;|4``: Cell averaging based on errors</span>
<span class="sd">            - ``&quot;cellave&quot;|-1``: Cell averaging</span>
<span class="sd">            - ``&quot;conserv&quot;|-1``: Conservative cel averaging</span>
<span class="sd">              (like ``cellave`` but with integral preserved)</span>

<span class="sd">        - **axis**, optional: Dimension (int) on which the interpolation is performed.</span>
<span class="sd">          If not specified, it is guessed from the</span>
<span class="sd">          input and output axis types, or set to ``0``.</span>
<span class="sd">        - **axi**, optional: Input axis. It defaults to the axis-th axis of ``vari``.</span>
<span class="sd">          Like ``axo``, it can be of any dimensions.</span>
<span class="sd">        - **iaxo**, optional: Dimension of ``axo`` on which the interpolation is performed</span>
<span class="sd">          when ``axo`` has more than one dimension.</span>
<span class="sd">        - **iaxi**, optional: Same as ``iaxo`` but for ``axi``.</span>
<span class="sd">        - **mask_thres**, optional: Time steps when interpolated mask is greater than</span>
<span class="sd">          this value are masked.</span>
<span class="sd">        - **extrap**, optional: Extrapolate outside input grid when the &quot;nearest&quot; method</span>
<span class="sd">          is used:</span>

<span class="sd">            - ``0`` or ``False``: No extrapolation.</span>
<span class="sd">            - ``-1`` or ``&quot;min&quot;``, or ``&quot;bottom&quot;``, or ``&quot;lower&quot;``, or ``&quot;first&quot;``:</span>
<span class="sd">              Extrapolate toward first values of the axis.</span>
<span class="sd">            - ``1`` or ``&quot;max&quot;``, or ``&quot;top&quot;``, or ``&quot;upper&quot;``, or ``&quot;last&quot;``:</span>
<span class="sd">              Extrapolate toward last values of the axis.</span>
<span class="sd">            - ``2`` or ``&quot;both&quot;``: Extrapolate toward both first and last values.</span>

<span class="sd">        - **erri**, optional: Input &quot;measurement&quot; errors with the same shape as input</span>
<span class="sd">          variable.</span>
<span class="sd">        - **errl**, optional: Derivative of lag error with respect to lag.</span>
<span class="sd">          Note that the lag must expressed in **days** for time axes.</span>
<span class="sd">          If positive, it based on quadratic errors, else on error itself.</span>
<span class="sd">          Estimate for instance it using the slope of a linear regression.</span>
<span class="sd">          It is usually varying in space and constant in time.</span>
<span class="sd">        - **geterr**, optional: When method is &quot;cellerr&quot;, also return the error</span>
<span class="sd">          along with the variable.</span>

<span class="sd">    :Examples:</span>

<span class="sd">        &gt;&gt;&gt; varo = regrid1d(vari, taxis, method=&#39;linear&#39;) # interpolation in time</span>
<span class="sd">        &gt;&gt;&gt; varo = regrid1d(vari, zo, axis=1) # Z interpolation on second axis</span>
<span class="sd">        &gt;&gt;&gt; varo = regrid1d(vari, zzo, iaxo=1, axi=zzi, iaxi=1) # sigma to sigma</span>

<span class="sd">    .. note::</span>

<span class="sd">        Cubic method, use &quot;linear&quot; interpolation when less than 4 valid points are available.</span>
<span class="sd">        Linear interpolation uses &quot;nearest&quot; interpolation when less than 2 points are</span>
<span class="sd">        available.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input specs</span>
    <span class="k">assert</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">),</span> <span class="s1">&#39;Works only with cdms variables&#39;</span>
    <span class="k">if</span> <span class="n">xmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xmapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;xmap and xmapper keywords of regrid1d are deprecated. &#39;</span>
            <span class="s1">&#39;Please use axi/axo and iaxi/iaxo keywords instead.&#39;</span><span class="p">,</span> <span class="n">VACUMMWarning</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">check_axes</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getOrder</span><span class="p">()</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
    <span class="n">missing_value</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">missing_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">N</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">missing_value</span><span class="p">):</span>
        <span class="n">vari</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>
    <span class="n">missing_value</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>

    <span class="c1"># Output axis</span>
    <span class="n">axon</span> <span class="o">=</span> <span class="n">axo</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">axon</span><span class="p">):</span> <span class="n">axon</span> <span class="o">=</span> <span class="n">axon</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>

    <span class="c1"># Working data axis</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 1D</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="c1"># Guess it</span>

        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">axo</span><span class="p">):</span> <span class="c1"># From axis type</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">axis_type</span><span class="p">(</span><span class="n">axo</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">axon</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># From axis length</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">_subshape_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Please, specify the &quot;axis&quot; parameter for interpolation&#39;</span><span class="p">)</span>

        <span class="c1"># Not found, so 0 without verification now (later)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">+=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Wrong &quot;axis&quot; parameter for interpolation&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Input axis</span>
    <span class="c1"># - get it</span>
    <span class="k">if</span> <span class="n">axi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">axi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># - special case for time axis: must have same units !</span>
    <span class="n">dxi2o</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">axis_type</span><span class="p">(</span><span class="n">axo</span><span class="p">),</span> <span class="n">order</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axo</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="n">are_same_units</span><span class="p">(</span><span class="n">axi</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">units</span><span class="p">)):</span>
        <span class="n">axi</span> <span class="o">=</span> <span class="n">ch_units</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">axo</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axou</span> <span class="o">=</span> <span class="n">axo</span><span class="o">.</span><span class="n">units</span>  <span class="c1">#.split(1)[0] + axi.units.split(1)[1]</span>
            <span class="n">dxi2o</span> <span class="o">=</span> <span class="p">(</span><span class="n">cdtime</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axou</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span>
                     <span class="n">cdtime</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axou</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">dxi2o</span> <span class="o">/=</span> <span class="p">(</span><span class="n">cdtime</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axi</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span>
                      <span class="n">cdtime</span><span class="o">.</span><span class="n">reltime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axi</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># - numeric version</span>
    <span class="n">axin</span> <span class="o">=</span> <span class="n">axi</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">axin</span><span class="p">):</span>
        <span class="n">axin</span> <span class="o">=</span> <span class="n">axin</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>

    <span class="c1"># Subaxes</span>
    <span class="n">nxo</span> <span class="o">=</span> <span class="n">axon</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">nxo</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iaxo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iaxo</span> <span class="o">=</span> <span class="n">_getiax_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iaxo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s2">&quot;Please, specifiy the &#39;iaxo&#39; parameter&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">iaxo</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">iaxo</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">iaxo</span> <span class="o">=</span> <span class="n">nxo</span><span class="o">+</span><span class="n">iaxo</span>
    <span class="n">nxi</span> <span class="o">=</span> <span class="n">axin</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">nxi</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iaxi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iaxi</span> <span class="o">=</span> <span class="n">_getiax_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axi</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iaxi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s2">&quot;Please, specifiy the &#39;iaxi&#39; parameter&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">iaxi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">iaxi</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">iaxi</span> <span class="o">=</span> <span class="n">nxi</span><span class="o">+</span><span class="n">iaxi</span>

    <span class="c1"># Verifications</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxi</span><span class="p">:</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxi</span><span class="o">+</span><span class="n">nxi</span><span class="p">]</span><span class="o">!=</span><span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s2">&quot;Input axis has a invalid shape: </span><span class="si">%s</span><span class="s2"> (!=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxi</span><span class="p">:</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxi</span><span class="o">+</span><span class="n">nxi</span><span class="p">]))</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxo</span><span class="p">:</span><span class="n">axis</span><span class="o">-</span><span class="n">iaxo</span><span class="o">+</span><span class="n">nxo</span><span class="p">])</span>
    <span class="n">vs</span><span class="p">[</span><span class="n">iaxo</span><span class="p">]</span> <span class="o">=</span> <span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">iaxo</span><span class="p">]</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vs</span><span class="o">!=</span><span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s2">&quot;Output axis has a invalid shape: </span><span class="si">%s</span><span class="s2"> (!=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">axo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vs</span><span class="p">))</span>

    <span class="c1"># Homogeneize axi and axo shapes (except for z dim)</span>
    <span class="n">iaxo_bak</span> <span class="o">=</span> <span class="n">iaxo</span>
    <span class="n">axin</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">,</span> <span class="n">axon</span><span class="p">,</span> <span class="n">iaxo</span> <span class="o">=</span> <span class="n">_syncshapes_</span><span class="p">(</span><span class="n">axin</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">,</span> <span class="n">axon</span><span class="p">,</span> <span class="n">iaxo</span><span class="p">)</span>

    <span class="c1"># Convert to numeric</span>
    <span class="n">varin</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>

    <span class="c1"># Push interpolation dimension to the right and convert to 1D or 2D arrays</span>
    <span class="n">varis</span><span class="p">,</span> <span class="n">bakmapv</span> <span class="o">=</span> <span class="n">_toright_</span><span class="p">(</span><span class="n">varin</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">vari2d</span> <span class="o">=</span> <span class="n">varis</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">axind</span><span class="p">,</span> <span class="n">bakmapi</span> <span class="o">=</span> <span class="n">_toright_</span><span class="p">(</span><span class="n">axin</span><span class="p">,</span> <span class="n">iaxi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axind</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">axind</span> <span class="o">=</span> <span class="n">axind</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">iaxi</span><span class="p">]))</span>
    <span class="n">axond</span><span class="p">,</span> <span class="n">bakmapo</span> <span class="o">=</span> <span class="n">_toright_</span><span class="p">(</span><span class="n">axon</span><span class="p">,</span> <span class="n">iaxo</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axond</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">axond</span> <span class="o">=</span> <span class="n">axond</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">iaxo</span><span class="p">]))</span>
    <span class="n">nxb</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">axind</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">axond</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">nxi</span> <span class="o">=</span> <span class="n">axind</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">nxo</span> <span class="o">=</span> <span class="n">axond</span><span class="o">.</span><span class="n">ndim</span>


    <span class="c1"># Method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">regrid_method</span><span class="p">(</span><span class="n">axin</span><span class="p">,</span> <span class="n">axon</span><span class="p">,</span> <span class="n">iaxi</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iaxo</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">regrid1d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_cellave_methods</span><span class="p">:</span>
        <span class="n">conserv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;conserv&#39;</span><span class="p">))</span>
<span class="c1">#       conserv = method == &#39;conservative&#39;</span>
        <span class="n">method</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;cellerr&#39;</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_interp1d_methods</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">_interp1d_methods</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="c1"># Wrong method</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">method</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Wrong method&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">method</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Hermit is always better</span>

    <span class="c1"># Cellerr</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>

        <span class="c1"># Measurement errors</span>
        <span class="k">if</span> <span class="n">erri</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;You must provide also erri for the &quot;cellerr&quot; method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">erri</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;vari and erro must have the same shape: </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span>
                <span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">erri</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">erris</span><span class="p">,</span> <span class="n">bakmapv</span> <span class="o">=</span> <span class="n">_toright_</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">erri</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">missing_value</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">errm</span> <span class="o">=</span> <span class="n">erris</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">erris</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Lag errors</span>
        <span class="k">if</span> <span class="n">errl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errl</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">errl</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">errl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">errl</span><span class="p">):</span>
            <span class="n">errl</span> <span class="o">=</span> <span class="n">errl</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>
        <span class="n">errl</span> <span class="o">=</span> <span class="n">errl</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">dxi2o</span>
        <span class="k">if</span> <span class="n">errl</span><span class="o">.</span><span class="n">size</span><span class="o">%</span><span class="n">nxi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;The size of errl (</span><span class="si">%i</span><span class="s1">) in not a multiple nxi (</span><span class="si">%i</span><span class="s1">).&#39;</span><span class="o">%</span>
                <span class="p">(</span><span class="n">errl</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">nxi</span><span class="p">))</span>


    <span class="c1"># Routine and arguments</span>
    <span class="k">if</span> <span class="n">nxi</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">nxo</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 1D-&gt;1D</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">_interp1d_</span>
        <span class="n">remap_func</span> <span class="o">=</span> <span class="n">_remap1d_</span>
        <span class="n">cellerr_func</span> <span class="o">=</span> <span class="n">_cellerr1d_</span>
    <span class="k">elif</span> <span class="n">nxo</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 1D-&gt;ND</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">_interp1dx_</span>
        <span class="n">remap_func</span> <span class="o">=</span> <span class="n">_remap1dx_</span>
        <span class="n">cellerr_func</span> <span class="o">=</span> <span class="n">_cellerr1dx_</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># ND-&gt;ND</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">_interp1dxx_</span>
        <span class="n">remap_func</span> <span class="o">=</span> <span class="n">_remap1dxx_</span>
        <span class="n">cellerr_func</span> <span class="o">=</span> <span class="n">_cellerr1dxx_</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># Cellave</span>
        <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">remap_func</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">conserv</span><span class="o">=</span><span class="n">conserv</span><span class="p">,</span><span class="n">extrap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">cellerr_func</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">errm</span><span class="o">=</span><span class="n">errm</span><span class="p">,</span> <span class="n">errl</span><span class="o">=</span><span class="n">errl</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Interp</span>
        <span class="n">regrid_func</span> <span class="o">=</span> <span class="n">interp_func</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="n">extrap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


    <span class="c1"># Regrid</span>
    <span class="n">varo2d</span> <span class="o">=</span> <span class="n">regrid_func</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="n">axind</span><span class="p">,</span> <span class="n">axond</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">varo2d</span><span class="p">,</span> <span class="n">erro2d</span> <span class="o">=</span> <span class="n">varo2d</span>


    <span class="c1"># Extrapolation</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">extrap</span> <span class="o">=</span> <span class="n">extrap</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">extrap</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">]:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extrap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">extrap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">extrap</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">extrap</span><span class="p">:</span>
        <span class="n">varo2d</span> <span class="o">=</span> <span class="n">_extrap1d_</span><span class="p">(</span><span class="n">varo2d</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">,</span> <span class="n">extrap</span><span class="p">)</span>

    <span class="c1"># Reshape back</span>
    <span class="n">varos</span> <span class="o">=</span> <span class="n">varo2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">axond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="p">;</span> <span class="k">del</span> <span class="n">varo2d</span>
    <span class="n">varon</span> <span class="o">=</span> <span class="n">varos</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">bakmapv</span><span class="p">)</span> <span class="p">;</span> <span class="k">del</span> <span class="n">varos</span>
    <span class="k">if</span> <span class="n">geterr</span> <span class="ow">and</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">erros</span> <span class="o">=</span> <span class="n">erro2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">axond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span> <span class="p">;</span> <span class="k">del</span> <span class="n">erro2d</span>
        <span class="n">erron</span> <span class="o">=</span> <span class="n">erros</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">bakmapv</span><span class="p">)</span> <span class="p">;</span> <span class="k">del</span> <span class="n">erros</span>

    <span class="c1"># Convert to cdms</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varon</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">geterr</span> <span class="ow">and</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">erro</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">erron</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>
        <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">erro</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">erro</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">erro</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="s1">&#39;_error&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">erro</span><span class="p">,</span> <span class="s1">&#39;long_name&#39;</span><span class="p">):</span>
            <span class="n">erro</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">erro</span><span class="o">.</span><span class="n">long_name</span><span class="o">+</span><span class="s1">&#39; error&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">erro</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;Error&#39;</span>
        <span class="n">erro</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="n">missing_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">axo</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">axo</span>
    <span class="k">elif</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">axo</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">axo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxo_bak</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">varo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nxo</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">odlaxis</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">axo</span><span class="p">[:]</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="n">oldaxis</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setAxisList</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">varo</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">geterr</span> <span class="ow">and</span> <span class="n">method</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
        <span class="n">erro</span><span class="o">.</span><span class="n">setAxisList</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">erro</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">varo</span><span class="p">,</span> <span class="n">erro</span>
    <span class="k">return</span> <span class="n">varo</span></div>


<div class="viewcode-block" id="nearest1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.nearest1d">[docs]</a><span class="k">def</span> <span class="nf">nearest1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation along an axes</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array</span>
<span class="sd">        - **axo**: Output cdms axis</span>
<span class="sd">        - **axis**, optional: Axis on wich to operate</span>
<span class="sd">        - Other keywords are passed to :func:`regrid1d`</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is an wrapper to :func:`regrid1d` using ``nearest`` as a default method.</span>
<span class="sd">        See its help for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="interp1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.interp1d">[docs]</a><span class="k">def</span> <span class="nf">interp1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Linear or cubic interpolation along an axes</span>


<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array</span>
<span class="sd">        - **axo**: Output cdms axis</span>
<span class="sd">        - **axis**, optional: Axis on wich to operate</span>
<span class="sd">        - Other keywords are passed to :func:`regrid1d`</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is an wrapper to :func:`regrid1d` using ``linear`` as a default method.</span>
<span class="sd">        See its help for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="cubic1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.cubic1d">[docs]</a><span class="k">def</span> <span class="nf">cubic1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cubic interpolation along an axes</span>


<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array</span>
<span class="sd">        - **axo**: Output cdms axis</span>
<span class="sd">        - **axis**, optional: Axis on wich to operate</span>
<span class="sd">        - Other keywords are passed to :func:`regrid1d`</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is an wrapper to :func:`regrid1d` using ``cubic`` as a default method.</span>
<span class="sd">        See its help for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="cellave1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.cellave1d">[docs]</a><span class="k">def</span> <span class="nf">cellave1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">conserv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cell averaging  or conservative regridding along an axis</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array</span>
<span class="sd">        - **axo**: Output cdms axis</span>
<span class="sd">        - **axis**, optional: Axis on wich to operate</span>
<span class="sd">        - **conservative**, optional: If True, regridding is conservative</span>
<span class="sd">        - Other keywords are passed to :func:`regrid1d`</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is an wrapper to :func:`regrid1d` using ``cellave`` or ``conservative`` as a default method.</span>
<span class="sd">        See its help for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;conservative&#39;</span><span class="p">,</span> <span class="n">conserv</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;conservative&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;cellave&#39;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">remap1d</span> <span class="o">=</span> <span class="n">cellave1d</span>

<div class="viewcode-block" id="cellerr1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.cellerr1d">[docs]</a><span class="k">def</span> <span class="nf">cellerr1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">erri</span><span class="p">,</span> <span class="n">errl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cell averaing with weights based on errors</span>


<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms array</span>
<span class="sd">        - **axo**: Output cdms axis</span>
<span class="sd">        - **erri**: Input measurement errors</span>
<span class="sd">        - **errl**, optional: Input lag error relative to lag</span>
<span class="sd">        - **axis**, optional: Axis on wich to operate</span>
<span class="sd">        - Other keywords are passed to :func:`regrid1d`</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is an wrapper to :func:`regrid1d` using ``cellerr`` method.</span>
<span class="sd">        See its help for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="fill1d2"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.fill1d2">[docs]</a><span class="k">def</span> <span class="nf">fill1d2</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">clip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">min_padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill missing values of a 1D array using spline interpolation.</span>

<span class="sd">    - **vi**: Input cdms variable</span>

<span class="sd">    - *k*: Order of splines [default: 1 = linear]</span>
<span class="sd">    - *padding*: Padding around an gap defining where on which part of the sample we must fit splines [default: max([min_padding,len(gap)*5])]</span>
<span class="sd">    - *min_padding*: See padding [default: k]</span>
<span class="sd">    - *method*: See :func:`interp1d` [default: linear]</span>

<span class="sd">    :Return:</span>
<span class="sd">        Filled :mod:`cdms2` variable</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">vi</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="s1">&#39;Input variable must be of rank 1&#39;</span>
    <span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">S</span>


    <span class="k">if</span> <span class="n">min_padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_padding</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">tc</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># Removes missing points</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span>
    <span class="n">cxi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
    <span class="n">cvi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
    <span class="n">cii</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)),</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cii</span><span class="p">)</span>
    <span class="n">cjj</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>

    <span class="c1"># Identify gaps</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">cii</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">cii</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">igaps</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">gaps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="n">cjj</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

    <span class="c1"># Output variable to refill</span>
    <span class="n">vo</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="c1"># Loop on gaps</span>
    <span class="k">for</span> <span class="n">igap</span> <span class="ow">in</span> <span class="n">igaps</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">gaps</span><span class="p">[</span><span class="n">igap</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">min_padding</span><span class="p">,</span><span class="n">gap</span><span class="o">*</span><span class="mi">5</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">min_padding</span><span class="p">,</span><span class="n">padding</span><span class="p">])</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">igap</span><span class="o">-</span><span class="n">pad</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">iend</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">nc</span><span class="p">,</span><span class="n">igap</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">pad</span><span class="p">])</span>
        <span class="n">splines</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">cxi</span><span class="p">[</span><span class="n">istart</span><span class="p">:</span><span class="n">iend</span><span class="p">],</span><span class="n">cvi</span><span class="p">[</span><span class="n">istart</span><span class="p">:</span><span class="n">iend</span><span class="p">],</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">vo</span><span class="p">[</span><span class="n">cii</span><span class="p">[</span><span class="n">igap</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">cii</span><span class="p">[</span><span class="n">igap</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">cii</span><span class="p">[</span><span class="n">igap</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">cii</span><span class="p">[</span><span class="n">igap</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">splines</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">vo</span></div>


<div class="viewcode-block" id="fill1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.fill1d">[docs]</a><span class="k">def</span> <span class="nf">fill1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">maxgap</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill missing values of a 1D array using interpolation.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input :mod:`cdms2` variable</span>
<span class="sd">        - *axis*: Axis number on which filling is performed</span>
<span class="sd">        - *method*: Interpolation method (see :func:`interp1d`)</span>
<span class="sd">        - *maxgap*: Maximal size of filled gaps (in steps)</span>

<span class="sd">    :Example:</span>

<span class="sd">        &gt;&gt;&gt; fill1d(vari, axis=2, method=&#39;cubic&#39;, maxgap=5)</span>

<span class="sd">    :Return:</span>
<span class="sd">        Filled :mod:`cdms2` variable similar to input one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">MV2</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span> <span class="k">return</span> <span class="n">vari</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">iaxis</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iaxis</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">nx</span>

    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vari</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>

    <span class="c1"># We need a 2D variable</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vari2d</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
        <span class="n">vari2d</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Numeric</span>
        <span class="n">varin</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
        <span class="c1"># Order</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">varin</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varis</span> <span class="o">=</span> <span class="n">varin</span>
        <span class="k">del</span> <span class="n">varin</span>
        <span class="c1"># 2D</span>
        <span class="n">ndshape</span> <span class="o">=</span> <span class="n">varis</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vari2d</span> <span class="o">=</span> <span class="n">varis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vari2d</span> <span class="o">=</span> <span class="n">varis</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>
        <span class="c1"># MV2</span>
        <span class="n">vari2d</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vari2d</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">)</span>
        <span class="n">vari2d</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">())</span>
        <span class="k">del</span> <span class="n">varis</span>


    <span class="c1"># Loop on extra dim</span>
    <span class="n">vari2dn</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
    <span class="n">varo2d</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">maxgap</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
    <span class="n">vari2dm</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>

        <span class="c1"># Mask</span>
        <span class="c1"># - base mask</span>
        <span class="n">xmask</span> <span class="o">=</span> <span class="n">vari2d</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">if</span> <span class="n">xmask</span> <span class="ow">is</span> <span class="n">MV2</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">or</span> <span class="n">xmask</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="o">~</span><span class="n">xmask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="k">continue</span>

        <span class="c1"># - check gaps</span>
        <span class="n">keep</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">~</span><span class="n">xmask</span>
        <span class="k">if</span> <span class="n">maxgap</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dd</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xmask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">))</span>
            <span class="n">gapstart</span> <span class="o">=</span> <span class="n">ii</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">dd</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">gapend</span> <span class="o">=</span> <span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">dd</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ie0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">gapend</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">gapstart</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">is1</span> <span class="o">=</span> <span class="p">(</span><span class="n">gapstart</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">gapend</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">nx</span>
            <span class="k">for</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gapstart</span><span class="p">[:</span><span class="n">is1</span><span class="p">],</span> <span class="n">gapend</span><span class="p">[</span><span class="n">ie0</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iend</span><span class="o">-</span><span class="n">istart</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxgap</span><span class="p">:</span>
                    <span class="n">keep</span><span class="p">[</span><span class="n">istart</span><span class="p">:</span><span class="n">iend</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">del</span> <span class="n">gapstart</span><span class="p">,</span> <span class="n">gapend</span>

        <span class="c1"># Compressed axis</span>
        <span class="n">caxis</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">[</span><span class="n">keep</span><span class="p">])</span>
        <span class="n">cp_atts</span><span class="p">(</span><span class="n">iaxis</span><span class="p">,</span> <span class="n">caxis</span><span class="p">)</span>

        <span class="c1"># Compressed variable</span>
        <span class="n">vari2dm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vari2d</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span>
        <span class="n">vari2dc</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vari2dm</span><span class="p">[</span><span class="n">keep</span><span class="p">])</span>
        <span class="n">vari2dc</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">caxis</span><span class="p">)</span>

        <span class="c1"># Interpolate</span>
        <span class="n">varo2d</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">vari2dc</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
<span class="c1">#       iaxisc = cdms2.createAxis(iaxis.getValue()[~keep])</span>
<span class="c1">#       if hasattr(iaxis, &#39;units&#39;): iaxisc.units = iaxis.units</span>
<span class="c1">#       varo2d[iy][~keep] = regrid1d(vari2dc, iaxisc, axis=0, method=method)</span>
        <span class="k">del</span> <span class="n">caxis</span><span class="p">,</span> <span class="n">vari2dc</span>

    <span class="k">if</span> <span class="n">maxgap</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span> <span class="k">del</span> <span class="n">ii</span><span class="p">,</span> <span class="n">dd</span>
    <span class="k">del</span> <span class="n">keep</span><span class="p">,</span> <span class="n">vari2dm</span>

    <span class="c1"># Back to correct dims</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">varo2d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">varo</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varo2d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo2dn</span> <span class="o">=</span> <span class="n">varo2d</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">varo2d</span>
        <span class="c1"># 2D</span>
        <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">varon</span> <span class="o">=</span> <span class="n">varo2dn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varon</span> <span class="o">=</span> <span class="n">varo2dn</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ndshape</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varo2dn</span>
        <span class="c1"># Order</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">varos</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">varon</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varos</span> <span class="o">=</span> <span class="n">varon</span>
        <span class="k">del</span> <span class="n">varon</span>
        <span class="c1"># MV2</span>
        <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varos</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">varo</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">varos</span>
    <span class="k">return</span> <span class="n">varo</span></div>


<div class="viewcode-block" id="fill2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.fill2d">[docs]</a><span class="k">def</span> <span class="nf">fill2d</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">xx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">yy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill missing value of 2D variable using inter/extrapolation</span>

<span class="sd">    - **var**: A cdms 2D variable.</span>
<span class="sd">    - *xx/yy*: Substitutes for axis coordinates [default: None]</span>
<span class="sd">    - Other keywords are passe to :func:`griddata`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Checkings</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">var</span><span class="p">):</span> <span class="n">var</span> <span class="o">=</span> <span class="n">cdms</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span> <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Input var must be at least 2D&#39;</span>

    <span class="c1"># Get Axes</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">yy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">yy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># Var</span>
    <span class="k">assert</span> <span class="n">xx</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="s1">&#39;2D axes and variable are not compatible in shape (</span><span class="si">%s</span><span class="s1"> against </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nex</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">var3d</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nex</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>  <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var3d</span> <span class="o">=</span> <span class="n">var</span>

    <span class="c1"># Mask</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">var3d</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="n">var3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">var3d</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Loop on extra dimensions</span>
    <span class="k">for</span> <span class="n">iex</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nex</span><span class="p">):</span>

        <span class="n">var2d</span> <span class="o">=</span> <span class="n">var3d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">mask2d</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask2d</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span>

        <span class="c1"># Unmasking</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">MV</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">or</span> <span class="n">mask2d</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="o">~</span><span class="n">mask2d</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="k">continue</span>
        <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask2d</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">yy</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">var2d</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>

        <span class="c1"># Gridding and filling</span>
        <span class="n">filled</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">),</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">var3d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">var2d</span><span class="p">,</span> <span class="n">filled</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">filled</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span>  <span class="n">good</span>

    <span class="c1"># Shape back</span>
    <span class="k">if</span> <span class="n">var3d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">var3d</span><span class="p">[:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">var3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>  <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">var</span></div>


<div class="viewcode-block" id="regular"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regular">[docs]</a><span class="k">def</span> <span class="nf">regular</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">auto_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill a variable with missing values when step of first axis is increasing</span>

<span class="sd">    - **vi**: Input array on almost regular axis</span>

<span class="sd">    - *dx*: Force grid step to this. Else, auto evaluated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">vacumm.misc</span> <span class="k">import</span> <span class="n">cp_atts</span>

    <span class="c1"># Guess info from input var</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">vi</span>
    <span class="n">xid</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">xtc</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
    <span class="n">missing_value</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Get dx and gaps</span>
    <span class="n">ddx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">xid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">ddx</span><span class="p">)</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">ddx</span> <span class="o">/</span> <span class="n">dx</span> <span class="o">-</span> <span class="mf">1.</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">less</span><span class="p">((</span><span class="n">gaps</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span><span class="n">N</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">gaps</span><span class="p">),</span><span class="n">gaps</span><span class="p">)</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">greater</span><span class="p">((</span><span class="n">gaps</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span><span class="p">,</span><span class="mf">0.9</span><span class="p">),</span><span class="n">N</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">gaps</span><span class="p">),</span><span class="n">gaps</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">)</span>
    <span class="n">ngaps</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_object</span><span class="p">(</span><span class="n">gaps</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
    <span class="n">gaps</span> <span class="o">=</span> <span class="n">gaps</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
    <span class="n">igaps</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">typecode</span><span class="o">=</span><span class="s1">&#39;l&#39;</span><span class="p">),</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
    <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">igaps</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ngaps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vi</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s1">&#39;Filled </span><span class="si">%i</span><span class="s1"> gaps with missing values&#39;</span> <span class="o">%</span> <span class="n">ngaps</span>

    <span class="c1"># Init output var</span>
    <span class="n">nxi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">nxo</span> <span class="o">=</span> <span class="n">nxi</span><span class="o">+</span><span class="n">ngaps</span>
    <span class="n">sho</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="p">;</span>  <span class="n">sho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxo</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nxo</span><span class="p">,</span><span class="n">typecode</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">vo</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span><span class="n">sho</span><span class="p">)</span>
    <span class="c1">#vo.id = vi.id+&#39;_regular&#39; ; vo.name = vo.id</span>

    <span class="c1"># Loop on first axis</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">igaps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">xo</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
    <span class="n">vi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vi</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ig</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">igaps</span><span class="p">):</span>
        <span class="c1"># Fill the gap</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">gaps</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span>
        <span class="n">xo</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">gap</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">xtc</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">vo</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_value</span>
        <span class="c1"># Fill values after the gap</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="n">gap</span>
        <span class="k">if</span> <span class="n">ig</span> <span class="o">==</span> <span class="n">ng</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">full</span> <span class="o">=</span> <span class="n">nxi</span><span class="o">-</span><span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full</span> <span class="o">=</span> <span class="n">igaps</span><span class="p">[</span><span class="n">ig</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">xo</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">full</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">full</span><span class="p">]</span>
        <span class="n">vo</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">full</span><span class="p">]</span> <span class="o">=</span> <span class="n">vi</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">full</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="n">full</span>

<span class="c1">##  xo[-1] = xi[-1]</span>
<span class="c1">##  vo[-1] = vi[-1]</span>

    <span class="c1"># Axes</span>
    <span class="n">vo</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_object</span><span class="p">(</span><span class="n">vo</span><span class="p">,</span><span class="n">missing_value</span><span class="p">)</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">cdms</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xo</span><span class="p">,</span><span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">axeso</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">axeso</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xo</span>
    <span class="n">vo</span><span class="o">.</span><span class="n">setAxisList</span><span class="p">(</span><span class="n">axeso</span><span class="p">)</span>
    <span class="n">vo</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">getGrid</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">auto_bounds</span><span class="p">:</span>
        <span class="n">vo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">bounds1d</span><span class="p">(</span><span class="n">vo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vo</span></div>



<div class="viewcode-block" id="regular_fill1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regular_fill1d">[docs]</a><span class="k">def</span> <span class="nf">regular_fill1d</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combination: fill1d(regular_fill)) (with their parameter)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fill1d</span><span class="p">(</span><span class="n">regular</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">),</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="spline_interp1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.spline_interp1d">[docs]</a><span class="k">def</span> <span class="nf">spline_interp1d</span><span class="p">(</span><span class="n">old_var</span><span class="p">,</span><span class="n">new_axis</span><span class="p">,</span><span class="n">check_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Backward compatibility function</span>

<span class="sd">    See :func:`regrid1d`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid1d</span><span class="p">(</span><span class="n">old_var</span><span class="p">,</span><span class="n">new_axis</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="GridData"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GridData">[docs]</a><span class="k">class</span> <span class="nc">GridData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;2D interpolator from a randomly spaced sample on a regular grid</span>

<span class="sd">    Possible algorithms:</span>

<span class="sd">    - Natural Neighbor using nat.Natgrid:</span>

<span class="sd">        - http://www.ncarg.ucar.edu//ngmath/natgrid/nnhome.html</span>
<span class="sd">        - http://www.cisl.ucar.edu/zine/98/spring/text/3.natgrid.html</span>
<span class="sd">        - http://dilbert.engr.ucdavis.edu/~suku/nem/nem_intro/node3.html</span>
<span class="sd">        - http://www.ems-i.com/gmshelp/Interpolation/Interpolation_Schemes/Natural_Neighbor_Interpolation.htm</span>

<span class="sd">    - 2D splines using css.css.Cssgrid</span>

<span class="sd">    :Parameters:</span>

<span class="sd">        - **xi**: Input 1D X positions.</span>
<span class="sd">        - **yi**: Input 1D Y positions.</span>
<span class="sd">        - **ggo**: Output grid. Can either (xo,yo), a cdms grid or a cdms variable with a grid.</span>
<span class="sd">        - *method*: Interpolator type, either &#39;nat&#39; (Natural Neighbors) or &#39;css&#39; (=&#39;splines&#39; using splines) [default: &#39;nat&#39;]</span>
<span class="sd">        - *nl*: Nonlinear interpolator (usually gives better results) [default: False]</span>
<span class="sd">        - *ext*: Extrapolate value outsite convex hull [**&#39;nat&#39; only**, default: False]</span>
<span class="sd">        - *mask*: Mask to apply to output data [default: None]</span>
<span class="sd">        - *compress*: If ``True``, interolate only unmasked data, and thus does not try guess the best mask (that&#39;s more efficient but very bad if data are masked!).</span>
<span class="sd">        - *sub*: Size of blocks for subblocking [**&quot;nat&quot; only**]</span>
<span class="sd">        - *margin*: Margin around ouput grid (or block) to select input data.</span>
<span class="sd">          Value is relative to X and Y extent.</span>
<span class="sd">        - Other keywords are set as attribute to the interpolator instance ; to get the list of parameters: ::</span>

<span class="sd">            &gt;&gt;&gt; import nat ; nat.printParameterTable()</span>
<span class="sd">            &gt;&gt;&gt; import css ; css.printParameterTable()</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; r = GridData(gridi, grido, method=&#39;nat&#39;, ext=False, margin=.7)</span>
<span class="sd">    &gt;&gt;&gt; varo1 = r(vari1)</span>
<span class="sd">    &gt;&gt;&gt; varo2 = r(vari2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">nl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">geo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nat&#39;</span><span class="p">,</span>
        <span class="n">sub</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">margin</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">vcdwarn</span><span class="p">(</span><span class="s1">&#39;GridData will no longer be supported in future version&#39;</span><span class="p">)</span>

        <span class="c1"># Helper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span> <span class="o">=</span> <span class="n">_GridDataHelper_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">geo</span><span class="o">=</span><span class="n">geo</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">)</span>

        <span class="c1"># Init interpolator</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;css&#39;</span><span class="p">,</span> <span class="s1">&#39;splines&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;css/spline method is no longer supported&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;natgrid&#39;</span><span class="p">]:</span>
            <span class="kn">from</span> <span class="nn">nat</span> <span class="k">import</span> <span class="n">Natgrid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">Natgrid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;nat&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">margin</span> <span class="o">=</span> <span class="n">margin</span>

        <span class="c1"># Attributes of interpolator</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;igr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ext&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;hor&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ver&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratts</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">xo</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">yo</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate zi on output grid</span>

<span class="sd">        - **zi**: At least a 1D array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Init</span>
        <span class="n">zi2d</span><span class="p">,</span> <span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="n">nex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>

        <span class="c1"># Prepare sub-blocks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">:</span>
            <span class="n">jbs</span> <span class="o">=</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ibs</span> <span class="o">=</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jbs</span> <span class="o">=</span> <span class="n">xrange</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ibs</span> <span class="o">=</span> <span class="n">xrange</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Loop on supplementary dims</span>
        <span class="k">for</span> <span class="n">iex</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nex</span><span class="p">):</span>

            <span class="c1"># Get data and mask</span>
            <span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">zi2d</span><span class="p">,</span> <span class="n">iex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">get</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mmi</span> <span class="o">=</span> <span class="n">get</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">zzi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span> <span class="k">break</span>
            <span class="c1"># Interpolate by blocks</span>
            <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="n">ibs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="n">jbs</span><span class="p">:</span>

                    <span class="c1"># Block</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">xslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="n">yslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ib</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">,(</span><span class="n">ib</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>
                        <span class="n">yslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">jb</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">,(</span><span class="n">jb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>
                    <span class="n">xo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">[</span><span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
                    <span class="n">yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">[</span><span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

                    <span class="c1"># Restriction of input data around output grid</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">margin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">margin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margin</span>
                        <span class="n">ngoodi</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">igoodi</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">enlarge</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>
                        <span class="k">while</span> <span class="n">ngoodi</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span> <span class="c1"># Loop to get a sufficient number of pts</span>
                            <span class="n">margin</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">enlarge</span><span class="o">*</span><span class="n">igoodi</span><span class="p">)</span>
                            <span class="n">dxo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">*</span><span class="n">margin</span>
                            <span class="n">dyo</span> <span class="o">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">*</span><span class="n">margin</span>
                            <span class="n">ximin</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dxo</span>
                            <span class="n">ximax</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dxo</span>
                            <span class="n">yimin</span> <span class="o">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dyo</span>
                            <span class="n">yimax</span> <span class="o">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dyo</span>
                            <span class="n">goodi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">&gt;</span><span class="n">ximin</span>
                            <span class="n">goodi</span> <span class="o">&amp;=</span> <span class="n">xi</span><span class="o">&lt;</span><span class="n">ximax</span>
                            <span class="n">goodi</span> <span class="o">&amp;=</span> <span class="n">yi</span><span class="o">&gt;</span><span class="n">yimin</span>
                            <span class="n">goodi</span> <span class="o">&amp;=</span> <span class="n">yi</span><span class="o">&lt;</span><span class="n">yimax</span>
                            <span class="n">ngoodi</span> <span class="o">=</span> <span class="n">goodi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                            <span class="n">igoodi</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">igoodi</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">:</span> <span class="k">break</span>
                        <span class="k">if</span> <span class="n">igoodi</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">goodi</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

                    <span class="c1"># Interpolator</span>
                    <span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">goodi</span><span class="p">],</span> <span class="n">yi</span><span class="p">[</span><span class="n">goodi</span><span class="p">],</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">listOutput</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">att</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">interpolator</span><span class="p">,</span> <span class="n">att</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">interpolator</span><span class="o">.</span><span class="n">nul</span> <span class="o">=</span> <span class="n">missing_value</span>

                    <span class="c1"># Interpolation</span>
                    <span class="k">if</span> <span class="n">constant</span><span class="p">:</span>
                        <span class="n">sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">[</span><span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">zzo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
                        <span class="n">zzo</span> <span class="o">+=</span> <span class="n">zzi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">mmi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">mmo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
                            <span class="n">mmo</span> <span class="o">+=</span> <span class="n">mmi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">[</span><span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">zzo</span> <span class="o">=</span> <span class="n">interpolator</span><span class="o">.</span><span class="n">rgrd</span><span class="p">(</span><span class="n">zzi</span><span class="p">[</span><span class="n">goodi</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mmi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">mmo</span> <span class="o">=</span> <span class="n">interpolator</span><span class="o">.</span><span class="n">rgrd</span><span class="p">(</span><span class="n">mmi</span><span class="p">[</span><span class="n">goodi</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>

                    <span class="n">zo3d</span><span class="p">[</span><span class="n">iex</span><span class="p">,</span> <span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span> <span class="o">=</span> <span class="n">zzo</span>
                    <span class="k">if</span> <span class="n">mmi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">mo3d</span><span class="p">[</span><span class="n">iex</span><span class="p">,</span> <span class="n">yslice</span><span class="p">,</span> <span class="n">xslice</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmo</span>
                        <span class="k">del</span> <span class="n">mmo</span>
                    <span class="k">del</span> <span class="n">zzo</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">zi2d</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">del</span> <span class="n">zi2d</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GDH</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">rgrd</span> <span class="o">=</span> <span class="fm">__call__</span>
    <span class="n">regrid</span> <span class="o">=</span> <span class="fm">__call__</span></div>

<div class="viewcode-block" id="cargen"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.cargen">[docs]</a><span class="k">def</span> <span class="nf">cargen</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolator from IFREMER</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **xi**: Input 1D X positions.</span>
<span class="sd">        - **yi**: Input 1D Y positions.</span>
<span class="sd">        - **ggo**, optional: Output grid. Can either (xo,yo), a cdms grid or a cdms variable with a grid.</span>
<span class="sd">        - **mask**, optional: Mask to apply to output data [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Helper</span>
    <span class="n">GDH</span> <span class="o">=</span> <span class="n">_GridDataHelper_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span>
                           <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">GDH</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">==</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span> <span class="s1">&#39;cargen works only with rectangular grids&#39;</span>

    <span class="c1"># Init data</span>
    <span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>

    <span class="c1"># Loop on supplementary dims</span>
    <span class="k">for</span> <span class="n">iex</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">GDH</span><span class="o">.</span><span class="n">nex</span><span class="p">):</span>

        <span class="c1"># Get data and mask</span>
        <span class="n">get</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">iex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">get</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mmi</span> <span class="o">=</span> <span class="n">get</span>

        <span class="c1"># Interpolate</span>
        <span class="n">zo3d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span> <span class="o">=</span> <span class="n">_cargen_</span><span class="p">(</span><span class="n">GDH</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">,</span>
            <span class="n">GDH</span><span class="o">.</span><span class="n">missing_value</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">mmi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mo3d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span> <span class="o">=</span> <span class="n">_cargen_</span><span class="p">(</span><span class="n">GDH</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="n">mmi</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Format output</span>
    <span class="k">return</span> <span class="n">GDH</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">krigdata</span> <span class="o">=</span> <span class="n">cargen</span>

<div class="viewcode-block" id="krig"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.krig">[docs]</a><span class="k">def</span> <span class="nf">krig</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Kriging interpolator to a grid</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **xi**: Input 1D X positions.</span>
<span class="sd">        - **yi**: Input 1D Y positions.</span>
<span class="sd">        - **zi**: Input N-D with last dim as space.</span>
<span class="sd">        - **ggo**, optional: Output grid. Can either (xo,yo), a cdms grid or a cdms variable with a grid.</span>
<span class="sd">        - **mask**, optional: Mask to apply to output data [default: None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Helper</span>
    <span class="k">assert</span> <span class="n">proj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
    <span class="n">GDH</span> <span class="o">=</span> <span class="n">_GridDataHelper_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Init data</span>
    <span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span>  <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>
    <span class="n">distfunc</span> <span class="o">=</span> <span class="s1">&#39;haversine&#39;</span> <span class="k">if</span> <span class="n">GDH</span><span class="o">.</span><span class="n">geo</span> <span class="k">else</span> <span class="s1">&#39;simple&#39;</span>

    <span class="c1"># Get data and mask</span>
    <span class="n">get</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">zi2d</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="n">compress</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">get</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gxi</span><span class="p">,</span> <span class="n">gyi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mmi</span> <span class="o">=</span> <span class="n">get</span>

        <span class="c1"># Interpolate</span>
        <span class="n">zo3d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_krig_</span><span class="p">(</span><span class="n">gxi</span><span class="p">,</span> <span class="n">gyi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">,</span>
                         <span class="n">distfunc</span><span class="o">=</span><span class="n">distfunc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zo3d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">gxi</span><span class="p">,</span> <span class="n">gyi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mmi</span>

    <span class="c1"># Format output</span>
    <span class="k">return</span> <span class="n">GDH</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="griddata"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.griddata">[docs]</a><span class="k">def</span> <span class="nf">griddata</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation in one single shot using GridData</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **xi**: 1D input x coordinates.</span>
<span class="sd">        - **yi**: 1D input y coordinates (same length as xi).</span>
<span class="sd">        - **zi**: 1D input values (same length as xi).</span>
<span class="sd">        - **method**, optional: Method of interpolation,</span>
<span class="sd">          within (&#39;nat&#39;, &#39;css&#39;, &#39;carg&#39;, &#39;krig&#39;) [default: &#39;carg&#39;]</span>
<span class="sd">        - **cgrid**, optional: Output on a C-grid at U- and V-points</span>
<span class="sd">          deduced from ggo [default: False].</span>
<span class="sd">          Not available for &#39;carg&#39; and &#39;krig&#39; methods.</span>

<span class="sd">    :See also: :class:`GridData` and :func:`cargen`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cgrid</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">griddata</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">gg</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">cgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">t2uvgrids</span><span class="p">(</span><span class="n">ggo</span><span class="p">)])</span>

    <span class="c1"># Method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;css&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="s1">&#39;nat&#39;</span><span class="p">):</span>
        <span class="n">vcdwarn</span><span class="p">(</span><span class="s1">&#39;Interpolation method other than nearest, linear or cubic&#39;</span>
                <span class="s1">&#39; will not be supported in future versions&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nat&#39;</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;css&#39;</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span>
    <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_griddata_methods</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Invalid interpolation method </span><span class="si">{}</span><span class="s1">.&#39;</span>
                                         <span class="s1">&#39; Please choose one of:&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                 <span class="n">method</span><span class="p">,</span>
                                                 <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_griddata_methods</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">proj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

    <span class="c1"># Scipy</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]:</span>

        <span class="c1"># Helper</span>
        <span class="n">GDH</span> <span class="o">=</span> <span class="n">_GridDataHelper_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">)</span>

        <span class="c1"># Data</span>
        <span class="n">GDH</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">initout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">GDH</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span>
            <span class="n">vcwarn</span><span class="p">(</span><span class="s2">&quot;Can&#39;t interpolate masked with cubic method &quot;</span>
                   <span class="s2">&quot;without compression. Switching compression on.&quot;</span><span class="p">)</span>
            <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Interpolator</span>
        <span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">SI</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">NearestNDInterpolator</span><span class="p">,</span>
                        <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">LinearNDInterpolator</span><span class="p">,</span>
                        <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">CloughTocher2DInterpolator</span><span class="p">}[</span><span class="n">method</span><span class="p">]</span>
        <span class="c1"># Get stuff</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">xyi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">xyi</span> <span class="o">=</span> <span class="n">get_tri</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">ttype</span><span class="o">=</span><span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>  <span class="c1"># triangulation</span>
        <span class="n">xyo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Interpolate</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;fill_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">missing_value</span>
        <span class="n">zo3d</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)(</span><span class="n">xyo</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">GDH</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
<span class="c1">#            if method != &#39;nearest&#39;:</span>
<span class="c1">#                kw[&#39;fill_value&#39;] = 1.</span>
            <span class="n">mo3d</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">mi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)(</span><span class="n">xyo</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mo3d</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Format output</span>
        <span class="k">return</span> <span class="n">GDH</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;krig&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">krig</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cargen</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_GridDataHelper_</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Input grid</span>
        <span class="k">assert</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">yi</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>   <span class="s1">&#39;xi and yi must be 1d arrays&#39;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">get_proj</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="n">proj</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span>


        <span class="c1"># - grid and axes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ongrid</span> <span class="o">=</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">ggo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">ggo</span><span class="p">,</span> <span class="n">gtype</span><span class="o">=</span><span class="n">gtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">=</span> <span class="n">get_grid_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getLongitude</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;rect&quot;</span> <span class="ow">and</span> <span class="n">proj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">!=</span> <span class="s1">&#39;unstruct&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yo</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="k">if</span> <span class="n">proj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="n">proj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># - mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ggo</span><span class="p">,</span> <span class="s1">&#39;getMask&#39;</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">ggo</span><span class="o">.</span><span class="n">getMask</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ggo</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">ggo</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compress</span> <span class="o">=</span> <span class="n">compress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inited</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">init_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initout</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init input before regridding&quot;&quot;&quot;</span>

        <span class="c1"># Convert to right dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inited</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span>
        <span class="n">nex</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">zi</span><span class="p">):</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nex</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="n">missing_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">zi</span><span class="p">):</span>
                <span class="n">missing_value</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">get_fill_value</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">missing_value</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">default_fill_value</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span> <span class="o">=</span> <span class="n">missing_value</span>
        <span class="n">unmasked</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">unmasked</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nex</span> <span class="o">=</span> <span class="n">nex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">initout</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Initialize output</span>
        <span class="n">zo3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">+</span> <span class="n">missing_value</span>
        <span class="k">if</span> <span class="n">unmasked</span><span class="p">:</span>
            <span class="n">compress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compress</span>
        <span class="k">if</span> <span class="n">compress</span> <span class="ow">or</span> <span class="n">unmasked</span><span class="p">:</span>
            <span class="n">mo3d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mo3d</span> <span class="o">=</span> <span class="n">zo3d</span><span class="o">*</span><span class="mf">0.</span>
        <span class="k">del</span> <span class="n">unmasked</span>

        <span class="k">return</span> <span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a slice&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inited</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Please call .init_data() before calling .get()&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iex</span> <span class="o">=</span> <span class="bp">Ellipsis</span>

        <span class="c1"># Remove compress values or fill them</span>
        <span class="n">good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mi</span> <span class="c1"># 1D</span>
        <span class="n">mmi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compress</span><span class="p">:</span> <span class="c1"># No compression =&gt; interpolation of mask</span>
                <span class="n">mmi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">good</span> <span class="o">=</span> <span class="n">good</span> <span class="o">&amp;</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">if</span> <span class="n">good</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">good</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># All data are bad</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">good</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">good</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="c1"># Some are good</span>
            <span class="n">zzi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">good</span><span class="p">]</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mmi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mmi</span> <span class="o">=</span> <span class="n">mmi</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># There are all good</span>
            <span class="n">zzi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi2d</span><span class="p">[</span><span class="n">iex</span><span class="p">]</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span>
        <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">zzi</span><span class="p">):</span>
            <span class="n">zzi</span> <span class="o">=</span> <span class="n">zzi</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">good</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mmi</span>


    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="n">clipval</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">asmv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format output variable&quot;&quot;&quot;</span>
        <span class="c1"># Shape</span>
        <span class="n">sho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">zo3d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sho</span><span class="p">:</span>
            <span class="n">zo</span> <span class="o">=</span> <span class="n">zo3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sho</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">zo3d</span>
            <span class="k">if</span> <span class="n">mo3d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mo</span> <span class="o">=</span> <span class="n">mo3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sho</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zo</span> <span class="o">=</span> <span class="n">zo3d</span>
            <span class="n">mo</span> <span class="o">=</span> <span class="n">mo3d</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">zo</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">zo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">zo</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span>
        <span class="k">if</span> <span class="n">mo3d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zo</span><span class="p">[</span><span class="n">mo</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">closeto</span><span class="p">(</span><span class="n">zo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_value</span><span class="p">)</span>

        <span class="c1"># Value clipping</span>
        <span class="k">if</span> <span class="n">clipval</span><span class="p">:</span>
            <span class="n">valmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">valmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">missing</span>
            <span class="n">zo</span><span class="p">[</span><span class="n">good</span><span class="o">&amp;</span><span class="p">(</span><span class="n">zo</span><span class="o">&gt;</span><span class="n">valmax</span><span class="p">)]</span> <span class="o">=</span> <span class="n">valmax</span>
            <span class="n">zo</span><span class="p">[</span><span class="n">good</span><span class="o">&amp;</span><span class="p">(</span><span class="n">zo</span><span class="o">&lt;</span><span class="n">valmin</span><span class="p">)]</span> <span class="o">=</span> <span class="n">valmin</span>

        <span class="c1"># Format</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">missing</span><span class="p">,</span> <span class="n">zo</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asmv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">asmv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ongrid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> <span class="s1">&#39;curv&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">asmv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zo</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zo</span><span class="p">)</span>
        <span class="n">set_grid</span><span class="p">(</span><span class="n">zo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="p">):</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="p">,</span> <span class="n">zo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zi</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)]):</span>
                <span class="n">zo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zo</span>

<div class="viewcode-block" id="xy2grid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.xy2grid">[docs]</a><span class="k">def</span> <span class="nf">xy2grid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alias for :func:`griddata`</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :class:`GridData` :func:`cargen` :func:`xy2grid`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">griddata</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="xy2xy"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.xy2xy">[docs]</a><span class="k">def</span> <span class="nf">xy2xy</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation between to unstructured grids using scipy</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **xi/yi**: 1D input positions</span>
<span class="sd">        - **zi**: atleast-1D input values</span>
<span class="sd">        - **xo,yo**: 1D output positions</span>
<span class="sd">        - *proj*: convert positions to meters using mercator projection</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Helper</span>
    <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">proj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
    <span class="n">GDH</span> <span class="o">=</span> <span class="n">_GridDataHelper_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">),</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                           <span class="n">gtype</span><span class="o">=</span><span class="s1">&#39;unstruct&#39;</span><span class="p">)</span>

    <span class="c1"># Data</span>
    <span class="n">GDH</span><span class="o">.</span><span class="n">init_data</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">initout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">GDH</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span>
        <span class="n">vcwarn</span><span class="p">(</span><span class="s2">&quot;Can&#39;t interpolate masked with cubic method &quot;</span>
               <span class="s2">&quot;without compression. Switching compression on.&quot;</span><span class="p">)</span>
        <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Interpolator</span>
    <span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">SI</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">NearestNDInterpolator</span><span class="p">,</span>
                    <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">LinearNDInterpolator</span><span class="p">,</span>
                    <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="n">SI</span><span class="o">.</span><span class="n">CloughTocher2DInterpolator</span><span class="p">}[</span><span class="n">method</span><span class="p">]</span>

    <span class="c1"># Get stuff</span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="n">xyi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">xyi</span> <span class="o">=</span> <span class="n">get_tri</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">ttype</span><span class="o">=</span><span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>  <span class="c1"># triangulation</span>
    <span class="n">xyo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">GDH</span><span class="o">.</span><span class="n">xo</span><span class="p">,</span> <span class="n">GDH</span><span class="o">.</span><span class="n">yo</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Interpolate</span>
    <span class="n">kw</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;fill_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GDH</span><span class="o">.</span><span class="n">missing_value</span>
    <span class="n">zo3d</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)(</span><span class="n">xyo</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">GDH</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">GDH</span><span class="o">.</span><span class="n">compress</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
<span class="c1">#        if method != &#39;nearest&#39;:</span>
<span class="c1">#            kw[&#39;fill_value&#39;] = 1.</span>
        <span class="n">mo3d</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xyi</span><span class="p">,</span> <span class="n">mi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)(</span><span class="n">xyo</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mo3d</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Format output</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;asmv&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GDH</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zo3d</span><span class="p">,</span> <span class="n">mo3d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1">#    # Check input positions</span>
<span class="c1">#    xi = N.asarray(xi, &#39;d&#39;)</span>
<span class="c1">#    yi = N.asarray(yi, &#39;d&#39;)</span>
<span class="c1">#    xo = N.asarray(xo, &#39;d&#39;)</span>
<span class="c1">#    yo = N.asarray(yo, &#39;d&#39;)</span>
<span class="c1">#    proj = kwargs.pop(&#39;geo&#39;, proj)</span>
<span class="c1">#    if proj:</span>
<span class="c1">#        if not callable(proj):</span>
<span class="c1">#            proj = get_proj((xi,yi))</span>
<span class="c1">#        xi, yi = proj(xi, yi)</span>
<span class="c1">#        xo, yo = proj(xo, yo)</span>
<span class="c1">#</span>
<span class="c1">#    # Check input type</span>
<span class="c1">#    outtype = 0</span>
<span class="c1">#    if cdms2.isVariable(zi):</span>
<span class="c1">#        outtype = 2</span>
<span class="c1">#        axes = zi.getAxisList()</span>
<span class="c1">#        atts = get_atts(zi)</span>
<span class="c1">#        zi = zi.asma()</span>
<span class="c1">#    elif N.ma.isMA(zi):</span>
<span class="c1">#        if zi.mask is not N.ma.nomask and zi.mask.any():</span>
<span class="c1">#            outtype = 1</span>
<span class="c1">#</span>
<span class="c1">#    # Check shapes</span>
<span class="c1">#    zi = zi.copy()</span>
<span class="c1">#    si = zi.shape</span>
<span class="c1">#    nsi = zi.shape[-1]</span>
<span class="c1">#    nex = zi.size/nsi</span>
<span class="c1">#    zi.shape = (nex, nsi)</span>
<span class="c1">#    nso = len(xo)</span>
<span class="c1">#    zo = N.zeros((nex, nso))</span>
<span class="c1">#    zo[:] = N.nan</span>
<span class="c1">#    if outtype:</span>
<span class="c1">#        mo = N.zeros((nex, nso))</span>
<span class="c1">#        goodi = ~zi.mask</span>
<span class="c1">#    else:</span>
<span class="c1">#        mo = None</span>
<span class="c1">#</span>
<span class="c1">#    # Loop on extra dim</span>
<span class="c1">#    from masking import convex_hull, polygon_select</span>
<span class="c1">#    for iex in xrange(nex):</span>
<span class="c1">#</span>
<span class="c1">#        if outtype:</span>
<span class="c1">#            gi = goodi[iex]</span>
<span class="c1">#            mi = zi.mask[iex].astype(&#39;f&#39;)</span>
<span class="c1">#        else:</span>
<span class="c1">#            gi = slice(None)</span>
<span class="c1">#</span>
<span class="c1">#        # Build regridder only when needed</span>
<span class="c1">#        if iex==0 or (outtype and N.any(goodi[iex-1]!=goodi[iex])):</span>
<span class="c1">#</span>
<span class="c1">#            # Check that output points are inside convex hull</span>
<span class="c1">#            hull = convex_hull((xi[gi], yi[gi]), poly=True)</span>
<span class="c1">#            go = polygon_select(xo, yo, [hull], mask=2) ; del hull</span>
<span class="c1">#            if go.all():</span>
<span class="c1">#                del go</span>
<span class="c1">#                go = slice(None)</span>
<span class="c1">#</span>
<span class="c1">#            # Regridder</span>
<span class="c1">#            from nat import Natgrid</span>
<span class="c1">#            r = Natgrid(xi[gi], yi[gi], xo[go], yo[go], listOutput=&#39;yes&#39;)</span>
<span class="c1">#            r.igr = int(nl)</span>
<span class="c1">#            if outtype:</span>
<span class="c1">#                rm = Natgrid(xi, yi, xo[go], yo[go], listOutput=&#39;yes&#39;)</span>
<span class="c1">#                rm.igr = int(nl)</span>
<span class="c1">#</span>
<span class="c1">#        # Regridding</span>
<span class="c1">#        # - values</span>
<span class="c1">#        zin = zi[iex][gi]</span>
<span class="c1">#        if N.ma.isMA(zin): zin = zin.filled()</span>
<span class="c1">#        zo[iex][go] = r.rgrd(zin)</span>
<span class="c1">#        # - mask</span>
<span class="c1">#        if outtype:</span>
<span class="c1">#            mo[iex][go] = rm.rgrd(mi)</span>
<span class="c1">#    del zi</span>
<span class="c1">#</span>
<span class="c1">#    # Missing points</span>
<span class="c1">#    mnan = N.isnan(zo)</span>
<span class="c1">#    if mnan.any():</span>
<span class="c1">#        outtype = max(1, outtype)</span>
<span class="c1">#        zo = N.ma.masked_where(mnan, zo)</span>
<span class="c1">#        del mnan</span>
<span class="c1">#</span>
<span class="c1">#    # Return pure numeric</span>
<span class="c1">#    zo.shape = si[:-1]+(nso, )</span>
<span class="c1">#    if outtype==0: return zo</span>
<span class="c1">#</span>
<span class="c1">#    # Masking</span>
<span class="c1">#    if mo is not None:</span>
<span class="c1">#        mo.shape = zo.shape</span>
<span class="c1">#        zo = N.ma.masked_where(mo&gt;.5, zo)</span>
<span class="c1">#        del mo, mi</span>
<span class="c1">#</span>
<span class="c1">#    # Masked arrays</span>
<span class="c1">#    if outtype == 1: return zo</span>
<span class="c1">#</span>
<span class="c1">#    # cdms</span>
<span class="c1">#    zo = MV2.asarray(zo)</span>
<span class="c1">#    set_atts(zo, atts)</span>
<span class="c1">#    for i, ax in axes[:-1]:</span>
<span class="c1">#        zo.setAxis(i, ax)</span>
<span class="c1">#    return zo</span>



<div class="viewcode-block" id="grid2xy"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.grid2xy">[docs]</a><span class="k">def</span> <span class="nf">grid2xy</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">zo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">distmode</span><span class="o">=</span><span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate gridded data to ramdom positions</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Input cdms variable on a grid</span>
<span class="sd">        - **xo**: Output longitudes</span>
<span class="sd">        - **yo**: Output latitudes</span>
<span class="sd">        - **method**, optional: Interpolation method</span>

<span class="sd">            - ``nearest``: Nearest neighbor</span>
<span class="sd">            - ``linear``: Linear interpolation</span>

<span class="sd">        - **zo**, optional: Output depths (negative in the ocean).</span>
<span class="sd">        - **to**, optional: Output times.</span>
<span class="sd">        - **zi**, optional: Input depths when variable in space.</span>

<span class="sd">        - **outaxis**, optional: Output spatial axis</span>

<span class="sd">            - A cdms2 axis.</span>
<span class="sd">            - ``None`` or ``&#39;auto&#39;``: Longitudes or latitudes depending</span>
<span class="sd">              on the range if coordinates are monotonic, else ``&#39;dist&#39;``.</span>
<span class="sd">            - ``&#39;lon&#39;`` or ``&#39;x&#39;``: Longitudes.</span>
<span class="sd">            - ``&#39;lat&#39;`` or ``&#39;y&#39;``: Latitudes.</span>
<span class="sd">            - ``&#39;dist&#39;`` or ``&#39;d&#39;``: Distance in km.</span>

<span class="sd">        - **distmode**, optional: Distance computation mode.</span>
<span class="sd">          See :func:`~vacumm.misc.grid.misc.get_distances`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Prefer 1D axes</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">curv2rect</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Format</span>

    <span class="c1"># - input data and coordinates</span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">get_xy</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rect</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span>
    <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getOrder</span><span class="p">()</span>
    <span class="n">vi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">univ</span> <span class="o">=</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="kc">True</span> <span class="c1"># FIXME: univ</span>
    <span class="n">na</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># interpolation dims</span>
    <span class="n">extra_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getLevel</span><span class="p">()</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">univ</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;nat&#39;</span><span class="p">:</span>
            <span class="n">vacumm_warn</span><span class="p">(</span><span class="s1">&#39;&quot;nat&quot; method not available with time or depth&#39;</span>
                        <span class="s1">&#39; interpolation. Switching to linear&#39;</span><span class="p">)</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

        <span class="n">it</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># not requested and not present</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">it</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">it</span><span class="p">:])</span> <span class="c1"># insert fake dim</span>
        <span class="k">elif</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># requested and present</span>
            <span class="n">na</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">taxis</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getTime</span><span class="p">()</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="n">taxis</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># present but not requested</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">it</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">it</span><span class="p">:])</span> <span class="c1"># insert fake dim</span>
            <span class="n">extra_axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getTime</span><span class="p">())</span>

        <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">zo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># not requested and not present</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span> <span class="c1"># insert fake dim</span>
        <span class="k">elif</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># requested and present</span>
            <span class="n">na</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span> <span class="c1"># no xy assumed</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span> <span class="c1"># with xy: left pad with ones</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="n">zi</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">+</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># present but not requested</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span> <span class="c1"># insert fake dim</span>
            <span class="k">if</span> <span class="n">extra_axes</span><span class="p">:</span> <span class="c1"># t as extra: ET1Z1YX -&gt; ETZ11YX</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># ETZ1YX -&gt; EZT1YX</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">extra_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getLevel</span><span class="p">())</span>

<span class="c1">#        if zo is not None:</span>
<span class="c1">#            zi = zi.reshape((-1, )+zi.shape[-4:])</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">yi</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>


        <span class="n">extra_axes</span> <span class="o">=</span> <span class="p">([</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">(),</span> <span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="n">o</span><span class="o">==</span><span class="s1">&#39;-&#39;</span><span class="p">]</span>
                      <span class="o">+</span> <span class="n">extra_axes</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">na</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>
<span class="c1">#    if zi.shape[0] != vi.shape[0]:</span>
<span class="c1">#        zi = N.resize(zi, vi.shape[:1] + zi.shape[1:])</span>


    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MV2</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># - output coordinates</span>
    <span class="n">isscalar</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
    <span class="n">no</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xo</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">yo</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">zo</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">no</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to</span><span class="p">),</span> <span class="n">no</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">xo</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">yo</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">xo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;xo and yo must be scalars 1d or arrays&#39;</span>
                                               <span class="s1">&#39; of equal lengths&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">xo</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">&gt;</span><span class="mf">180.</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">&lt;</span><span class="n">xo</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">+</span> <span class="mf">360.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">-</span> <span class="mf">360.</span>
    <span class="k">if</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">zo</span><span class="p">[:])</span>
        <span class="k">assert</span> <span class="n">zo</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">xo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="p">(</span><span class="s1">&#39;zo must have the same shape as xo and yo&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_time</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
        <span class="n">to</span><span class="o">.</span><span class="n">toRelativeTime</span><span class="p">(</span><span class="n">taxis</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="n">to</span> <span class="o">=</span> <span class="n">to</span><span class="p">[:]</span>
        <span class="k">assert</span> <span class="n">to</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span> <span class="n">xo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="p">(</span><span class="s1">&#39;&quot;to&quot; must have the same shape as xo and yo&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">to</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># Interpolate</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">univ</span><span class="p">:</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rect</span><span class="p">:</span>
                <span class="n">targets</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">subdims</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s1">&#39;nat&#39;</span> <span class="ow">and</span> <span class="n">mi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">univ</span><span class="p">:</span>
            <span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">_monotonise_</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span>
                <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span> <span class="n">subdims</span><span class="o">=</span><span class="n">subdims</span><span class="p">)</span>
            <span class="n">vo</span> <span class="o">=</span> <span class="n">_nearest4dto1dxx_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">zo</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rect</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_nearest2dto1d_</span>
                <span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">_monotonise_</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_nearest2dto1dc_</span>
            <span class="n">vo</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;nat&#39;</span> <span class="ow">and</span> <span class="n">mi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vonear</span> <span class="o">=</span> <span class="n">vo</span>

    <span class="k">if</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">univ</span><span class="p">:</span>
            <span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">_monotonise_</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">ti</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span>
                <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span> <span class="n">subdims</span><span class="o">=</span><span class="n">subdims</span><span class="p">)</span>
            <span class="n">vo</span> <span class="o">=</span> <span class="n">_linear4dto1dxx_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">zo</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rect</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_bilin2dto1d_</span>
                <span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">_monotonise_</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_bilin2dto1dc_</span>
            <span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">_monotonise_</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">])</span>
            <span class="n">vo</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>


<span class="c1">#    elif method.startswith(&#39;nat&#39;):</span>
<span class="c1">#</span>
<span class="c1">#        # Build regridder</span>
<span class="c1">#        from nat import Natgrid</span>
<span class="c1">#        nz = vi.shape[0]</span>
<span class="c1">#        vo = N.zeros((nz, len(xo)))+mv</span>
<span class="c1">#        if xi.ndim==1:</span>
<span class="c1">#            xxi, yyi = xi, yi</span>
<span class="c1">#        else:</span>
<span class="c1">#            xxi, yyi = N.meshgrid(xi, yi)</span>
<span class="c1">#        r = Natgrid(xxi.ravel(), yyi.ravel(), xo, yo, listOutput=&#39;yes&#39;)</span>
<span class="c1">#        if mi is not None:</span>
<span class="c1">#            mo = N.zeros(len(xo))</span>
<span class="c1">#</span>
<span class="c1">#        # Z loop interpolation</span>
<span class="c1">#        for iz in xrange(nz):</span>
<span class="c1">#</span>
<span class="c1">#            # Base</span>
<span class="c1">#            vo[iz] = r.rgrd(vi[iz].ravel())</span>
<span class="c1">#</span>
<span class="c1">#            # Mask</span>
<span class="c1">#            if mi is not None:</span>
<span class="c1">#                mo[:] = r.rgrd(mi[iz].ravel())</span>
<span class="c1">#                vo[iz] = N.where(mo!=0., vonear[iz], vo[iz])</span>
<span class="c1">#</span>
<span class="c1">#        if mi is not None:</span>
<span class="c1">#            del mi, mo, vonear</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="s1">&#39;Method yet not implemented: &#39;</span><span class="o">+</span><span class="n">method</span>

    <span class="c1"># Output</span>
    <span class="n">vo</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">extra_axes</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">vo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">)</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">vo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outaxis</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">outaxis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#xom, yom = get_proj((xo, yo))(xo, yo)</span>
            <span class="k">if</span> <span class="n">outaxis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outaxis</span> <span class="o">=</span> <span class="s1">&#39;lon&#39;</span> <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span><span class="o">&gt;</span><span class="n">N</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">yo</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;lat&#39;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">outaxis</span><span class="o">==</span><span class="s1">&#39;lon&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xo</span><span class="p">)))</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">outaxis</span><span class="o">==</span><span class="s1">&#39;lat&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yo</span><span class="p">)))</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yo</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())):</span>
                    <span class="n">outaxis</span> <span class="o">=</span> <span class="s1">&#39;dist&#39;</span>
        <span class="k">elif</span> <span class="n">isscalar</span><span class="p">:</span>
            <span class="n">outaxis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outaxis</span> <span class="o">=</span> <span class="s1">&#39;lon&#39;</span>
    <span class="k">elif</span> <span class="n">outaxis</span><span class="o">==</span><span class="s1">&#39;num&#39;</span> <span class="ow">or</span> <span class="n">outaxis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">varo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">]:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_lon</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">]:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_lat</span><span class="p">(</span><span class="n">yo</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_time</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">zo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;dep&#39;</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">]:</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_dep</span><span class="p">(</span><span class="n">zo</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">outaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">]:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">xo</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">yo</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">xo</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yo</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">pairwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">distmode</span><span class="p">)))</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">*</span><span class="mf">0.001</span>
        <span class="c1">#dist = get_distances(xo[0], yo[0], xo, yo, mode=distmode)*0.001</span>
        <span class="c1">#dist = N.concatenate(([0],N.sqrt(N.diff(xom)**2+N.diff(yom)**2)*0.001)).cumsum()</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
        <span class="n">outaxis</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;Distance along transect&#39;</span>
        <span class="n">outaxis</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;km&#39;</span>
    <span class="k">if</span> <span class="n">outaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">outaxis</span><span class="p">):</span>
        <span class="n">outaxis</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">outaxis</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
        <span class="n">outaxis</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;Position along transect&#39;</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">extra_axes</span>
    <span class="k">if</span> <span class="n">outaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outaxis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">varo</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">varo</span><span class="p">):</span>
        <span class="n">varo</span><span class="o">.</span><span class="n">setAxisList</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">varo</span></div>


<div class="viewcode-block" id="transect"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.transect">[docs]</a><span class="k">def</span> <span class="nf">transect</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">depths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
        <span class="n">subsamp</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">getcoords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a transect in a -[T][Z]YX variable</span>

<span class="sd">    It calls :func:`~vacumm.misc.grid.transect_specs` to compute transect</span>
<span class="sd">    coordinates when not explictly specified, and :func:`grid2xy` to perform</span>
<span class="sd">    4D interpolations.</span>

<span class="sd">    :Example:</span>

<span class="sd">        &gt;&gt;&gt; tsst = transect(sst, (1,1.6), (42.,43.), subsamp=4)</span>
<span class="sd">        &gt;&gt;&gt; tmld = transect(mld, [1.,1.,2.], [42.,43.,43.], outaxis=&#39;dist&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tprof = transect(temp, 1., 42.)</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **var**: MV2 array of at least rank 2 (YX).</span>
<span class="sd">        - **lons/lats**: Specification of transect, either</span>

<span class="sd">            - Coordinates of first and last point in degrees as</span>
<span class="sd">              tuples in the form ``(lon0,lon1)`` and ``(lat0,lat1)``.</span>
<span class="sd">              The array of coordinates is generated using :func:`transect_specs`.</span>
<span class="sd">            - Or explicit array of coordinates (as scalars, lists or arrays).</span>

<span class="sd">        - **depths**, optional: Output depths. If not a tuple, it must have</span>
<span class="sd">          the same size as lons and lats.</span>
<span class="sd">        - **times**, optional: Tuple, or time sequence or axis of the same length as</span>
<span class="sd">          resulting coordinates. If provided, the interpolation is first done</span>
<span class="sd">          in space, them onto this lagrangian time,</span>
<span class="sd">          and the final space-time trajectory is returned.</span>
<span class="sd">          If ``outaxis`` is None, ``taxis`` becomes the output axis.</span>

<span class="sd">        - **subsamp**, optional: Subsampling with respect to grid cell</span>
<span class="sd">          (only when coordinates are not explicit).</span>
<span class="sd">        - **method**, optional: Interpolation method (see :func:`grid2xy`).</span>
<span class="sd">        - **getcoords**, optional: Also get computed coordiantes.</span>
<span class="sd">        - **outaxis**, optional: Output spatial axis (see :func:`grid2xy`).</span>

<span class="sd">    :Return:</span>

<span class="sd">        ``tvar`` or ``tvar,tons,tlats``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Output coordinates</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span> <span class="c1"># backward compat</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="c1"># Find coordinates</span>
        <span class="n">lon0</span><span class="p">,</span> <span class="n">lon1</span> <span class="o">=</span> <span class="n">lons</span>
        <span class="n">lat0</span><span class="p">,</span> <span class="n">lat1</span> <span class="o">=</span> <span class="n">lats</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">transect_specs</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lon0</span><span class="p">,</span> <span class="n">lat0</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">subsamp</span><span class="o">=</span><span class="n">subsamp</span><span class="p">)</span>
        <span class="n">single</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># explicit coordinates</span>
        <span class="n">single</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="ow">and</span> <span class="n">N</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">depths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">depths</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Your depths axis must have a length of: </span><span class="si">%i</span><span class="s1"> (!=</span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">depths</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lons</span><span class="o">.</span><span class="n">getTime</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">getTime</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">lindates</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">istime</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create_time</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Your times must have a length of: </span><span class="si">%i</span><span class="s1"> (!=</span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)))</span>

    <span class="c1"># Interpolation</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">grid2xy</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">zo</span><span class="o">=</span><span class="n">depths</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=</span><span class="n">outaxis</span><span class="p">)</span>

    <span class="c1"># Single point</span>
    <span class="k">if</span> <span class="n">single</span><span class="p">:</span> <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">getcoords</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">var</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span>
    <span class="k">if</span> <span class="n">depths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">+=</span> <span class="n">depths</span><span class="p">,</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">+=</span> <span class="n">times</span><span class="p">,</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">var</span><span class="p">,)</span> <span class="o">+</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="refine"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.refine">[docs]</a><span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">geo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smoothcoast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noaxes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Refine a variable on a grid by a factor</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: 1D or 2D variable.</span>
<span class="sd">        - **factor**: Refinement factor &gt; 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># No refinement</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vari</span>

    <span class="c1"># Initialize</span>
    <span class="k">if</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">MA</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">sho</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">nxy</span> <span class="ow">in</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">sho</span> <span class="o">+=</span> <span class="p">((</span><span class="n">nxy</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sho</span><span class="p">,</span> <span class="n">vari</span><span class="p">[:]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">TransientAxis</span><span class="p">):</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">cdms</span><span class="o">.</span><span class="n">createAxis</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
        <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">geo</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">):</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">cdms</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">varo</span><span class="p">)</span>
        <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">geo</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Fill</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">factor</span>
    <span class="k">if</span> <span class="n">vari</span><span class="p">[:]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 1D linear</span>
        <span class="n">varo</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">factor</span><span class="p">]</span> <span class="o">=</span> <span class="n">vari</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
            <span class="n">varo</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">factor</span><span class="p">]</span> <span class="o">=</span> <span class="n">vari</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">vari</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">vari</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">step</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># 2D bilinear</span>
        <span class="c1">#FIXME: considerer les axes 2D en input et output</span>

        <span class="c1"># Bilinear on pure numeric values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">xo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">yo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">yi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">)</span>
            <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_mbilin2d_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xxo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">yyo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span>
                <span class="mf">1.e20</span><span class="p">,</span> <span class="n">smoothcoast</span><span class="p">,</span> <span class="n">nogeo</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">geo</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Masked data</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">varo</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>
            <span class="c1"># Grids</span>
            <span class="k">if</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">):</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">yi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">xo</span> <span class="o">=</span> <span class="n">refine</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">yo</span> <span class="o">=</span> <span class="n">refine</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">yi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">xo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">yo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">yi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xo</span><span class="p">[:],</span> <span class="n">yo</span><span class="p">[:])</span>

            <span class="c1"># Interpolation</span>
            <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_mbilin2d_</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">),</span><span class="n">xi</span><span class="p">[:],</span> <span class="n">yi</span><span class="p">[:],</span> <span class="n">xxo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">yyo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span>
                <span class="mf">1.e20</span><span class="p">,</span> <span class="n">smoothcoast</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">),</span><span class="n">N</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xxo</span><span class="p">),</span><span class="n">geo</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Masking</span>
            <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MV</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
                <span class="n">fmaski</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
                <span class="n">fmasko</span> <span class="o">=</span> <span class="n">_mbilin2d_</span><span class="p">(</span><span class="n">fmaski</span><span class="p">,</span><span class="n">xi</span><span class="p">[:],</span> <span class="n">yi</span><span class="p">[:],</span> <span class="n">xxo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">yyo</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span>
                    <span class="mf">1.e20</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">),</span><span class="n">N</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xxo</span><span class="p">),</span><span class="n">geo</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">fmasko</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">varo</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="mf">1.e20</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Axes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">noaxes</span> <span class="ow">and</span> <span class="n">cdms</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">varo</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="c1">#                   varo.setAxis(i, refine(vari.getAxis(i), factor))</span>
                    <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">xo</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">varo</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="n">create_grid</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span><span class="n">yo</span><span class="p">,</span><span class="n">fmasko</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">varo</span></div>
<span class="n">_cellave_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;conservative&#39;</span><span class="p">,</span> <span class="s1">&#39;remap&#39;</span><span class="p">,</span> <span class="s1">&#39;cellave&#39;</span><span class="p">,</span> <span class="s1">&#39;conserv&#39;</span><span class="p">]</span>
<span class="n">_cdat_methods</span> <span class="o">=</span> <span class="n">_cellave_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;bilinear&#39;</span><span class="p">]</span>
<span class="n">_regrid2d_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;mixt&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;bining&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">_griddata_methods</span><span class="o">+</span><span class="n">_cdat_methods</span>

<div class="viewcode-block" id="regrid2d_method_name"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid2d_method_name">[docs]</a><span class="k">def</span> <span class="nf">regrid2d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the method name and return its generic name&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;auto&#39;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cons&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;conserv&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;remap&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;cellave&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;lin&#39;</span> <span class="ow">in</span> <span class="n">method</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;interp&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;bilinear&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;bining&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nat&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;nat&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;near&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;nearest&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;carg&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;krig&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;carg&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;dst&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;dstwgt&quot;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;pat&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;patch&quot;</span>
    <span class="k">if</span> <span class="n">raiseerr</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Invalid regrid2d method. Please use for example one of these: &#39;</span><span class="o">+</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_regrid2d_methods</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span></div>

<span class="c1">#: Available tools for each method</span>
<span class="n">regrid2_tools</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
    <span class="p">(</span><span class="s1">&#39;cellave&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;regrid2&#39;</span><span class="p">,</span> <span class="s1">&#39;esmf&#39;</span><span class="p">],</span> <span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;esmf&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;conserv&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;regrid2&#39;</span><span class="p">,</span> <span class="s1">&#39;esmf&#39;</span><span class="p">],</span> <span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;esmf&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">,</span><span class="s1">&#39;esmf&#39;</span><span class="p">,</span><span class="s1">&#39;libcf&#39;</span><span class="p">],</span> <span class="n">r2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">,</span><span class="s1">&#39;esmf&#39;</span><span class="p">,</span><span class="s1">&#39;libcf&#39;</span><span class="p">],</span>
        <span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;esmf&#39;</span><span class="p">,</span> <span class="s1">&#39;libcf&#39;</span><span class="p">,</span> <span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;patch&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;esmf&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;dstwgt&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">],</span> <span class="n">c2c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;carg&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;nat&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
    <span class="p">(</span><span class="s1">&#39;bining&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c2r</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vacumm&#39;</span><span class="p">])),</span>
<span class="p">])</span>

<div class="viewcode-block" id="regrid2d_tool_name"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid2d_tool_name">[docs]</a><span class="k">def</span> <span class="nf">regrid2d_tool_name</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the tool name and return its generic name&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tool</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;auto&#39;</span>
    <span class="n">tool</span> <span class="o">=</span> <span class="n">tool</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;es&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;esmf&#39;</span>
    <span class="k">if</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;lib&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;libcf&#39;</span>
    <span class="k">if</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;cd&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;reg&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;regrid2&#39;</span>
    <span class="k">if</span> <span class="n">tool</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;vacumm&#39;</span>
    <span class="k">if</span> <span class="n">raiseerr</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Invalid regrid2d tool. Please use for example one of these: &#39;</span><span class="o">+</span>
            <span class="s1">&#39;regrid2, esmf, libcf, vacumm, auto&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span></div>


<div class="viewcode-block" id="regrid2dold"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid2dold">[docs]</a><span class="k">def</span> <span class="nf">regrid2dold</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">mask_thres</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">bilinear_masking</span><span class="o">=</span><span class="s1">&#39;dstwgt&#39;</span><span class="p">,</span> <span class="n">ext_masking</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="n">cdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">getcdr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usecdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useoldcdr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clipminmax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">geo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Regrid a variable from a regular grid to another</span>

<span class="sd">    If the input or output grid is curvilinear and ``method`` is set to</span>
<span class="sd">    ``&quot;linear&quot;``, ``&quot;cellave&quot;`` or ``&quot;conserv&quot;``, the :class:`CDATRegridder` is used.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Variable cdms on regular grid</span>
<span class="sd">        - **ggo**: Tuple of (x,y) or a cdms grid or a cdms variable with a grid</span>
<span class="sd">        - **method**, optional: One of:</span>

<span class="sd">            - ``&quot;auto&quot;``: method guessed according to resolution of input and output grid (see :func:`regrid_method`)</span>
<span class="sd">            - ``&quot;nearest&quot;``: nearest neighbour</span>
<span class="sd">            - ``&quot;linear&quot;`` or ``&quot;bilinear&quot;``: bilinear interpolation (low res. to high res.)</span>
<span class="sd">            - ``&quot;dstwgt&quot;`` : distance weighting (low res. to high res.)</span>
<span class="sd">            - ``&quot;cellave&quot;`` : weighted regridding based on areas of cells (high res. to low res.)</span>
<span class="sd">            - ``&quot;conserv&quot;`` : same as ``cell`` but conservative (high res. to low res.)</span>
<span class="sd">            - ``&quot;bining&quot;`` : simple averaging using bining (very high res. to low res.)</span>
<span class="sd">            - ``&quot;nat&quot;`` : Natgrid interpolation (low res. to high res.) (see :class:`GridData` for more info)</span>
<span class="sd">            - ``&quot;carg&quot;`` : Interpolation with minicargen(low res. to high res.) (see :func:`cargen` for more info)</span>

<span class="sd">        - **cdr**, optional: :class:`CDATRegridder` instance.</span>
<span class="sd">        - **getcdr**, optional: Also return the computed :class:`CDATRegridder` instance.</span>
<span class="sd">        - **usecdr**, optional: Force the use or not of a :class:`CDATRegridder` instance,</span>
<span class="sd">          even for rectangular grids.</span>
<span class="sd">        - **useoldcdr**, optional: Force the use the old CDAT regridder (rectangular grids only).</span>
<span class="sd">        - **ext**, optional: Perform extrapolation when possible</span>
<span class="sd">        - **bilinear_masking**: the way to handle interpolation near masked values</span>

<span class="sd">            - ``&quot;nearest&quot;``: brut masking using nearest neighbor</span>
<span class="sd">            - ``&quot;dstwgt&quot;`` : distance weight data are used where interpolated mask is lower ``mask_thres``</span>

<span class="sd">        - **mask_thres**, optional: Threshold for masking points for some methods (~ land fraction) for</span>
<span class="sd">          **rectangular grids only**:</span>

<span class="sd">            - ``method=&quot;bilinear&quot;`` and ``bilinear_masking=&quot;dstwght&quot;``</span>
<span class="sd">            - ``method=&quot;cellave&quot;`` or ``method=&quot;bining&quot;``</span>

<span class="sd">        - **ext_masking**, optional: Manual masking method when ``ext=False`` (when needed)</span>
<span class="sd">            with methods [&quot;carg&quot;,] (see :func:`~vacumm.misc.grid.masking.grid_envelop_mask`)</span>
<span class="sd">            if input grid is not rectangular</span>

<span class="sd">            - ``&quot;poly&quot;``: use the polygon defined by the input grid envelopp and check if output points are inside</span>
<span class="sd">            - ``&quot;nearest&quot;``: use hack with nearest 2d interpolation</span>

<span class="sd">        - Other keywords are passed to special interpolation functions depending on method and choices :</span>

<span class="sd">            - :func:`cargen` when &quot;nat&quot; or &quot;carg&quot; method is used</span>
<span class="sd">            - **mask_thres**, optional: Time steps when interpolated mask is greater than</span>
<span class="sd">              this value are masked.</span>

<span class="sd">    :Examples:</span>

<span class="sd">        &gt;&gt;&gt; regrid2d(var, (lon, lat), method=&#39;bilinear&#39;, bilinear_masking=&#39;nearest&#39;)</span>
<span class="sd">        &gt;&gt;&gt; regrid2d(var, grid, method=&#39;cellave&#39;, mask_thres=.8)</span>
<span class="sd">        &gt;&gt;&gt; regrid2d(var, grid, method=&#39;nat&#39;, hor=.2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Method</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">regrid_method</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">))</span>

    <span class="c1"># Check mask, grids and method</span>
    <span class="n">vari</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vari</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>
    <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="n">maski</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">if</span> <span class="n">maski</span> <span class="ow">is</span> <span class="n">MV</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
        <span class="n">check_mask</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">check_mask</span><span class="p">:</span>
        <span class="n">maski</span> <span class="o">=</span> <span class="n">maski</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="n">ggi</span> <span class="o">=</span> <span class="n">curv2rect</span><span class="p">(</span><span class="n">get_grid</span><span class="p">(</span><span class="n">vari</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">ggi</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nzi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">nxi</span><span class="o">*</span><span class="n">nyi</span><span class="p">)</span>
    <span class="n">ggo</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">ggo</span><span class="p">)</span>
    <span class="n">ggor</span> <span class="o">=</span> <span class="n">curv2rect</span><span class="p">(</span><span class="n">ggo</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span> <span class="o">=</span> <span class="n">ggo</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">loni</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lati</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lono</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lato</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggor</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">lono</span><span class="p">[:]</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">lato</span><span class="p">[:]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">loni</span><span class="p">[:]</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">lati</span><span class="p">[:]</span>
    <span class="n">curvedi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span>
    <span class="n">curvedo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span>
    <span class="n">curved</span> <span class="o">=</span> <span class="n">curvedi</span> <span class="ow">or</span> <span class="n">curvedo</span>
    <span class="n">curvedio</span> <span class="o">=</span> <span class="n">curvedi</span> <span class="ow">and</span> <span class="n">curvedo</span>
    <span class="n">xxi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">geo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">geo</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">islon</span><span class="p">(</span><span class="n">loni</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">islat</span><span class="p">(</span><span class="n">lati</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">islon</span><span class="p">(</span><span class="n">lono</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="o">.</span><span class="n">islat</span><span class="p">(</span><span class="n">lato</span><span class="p">)</span>

    <span class="c1"># Bounds</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_cellave_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">]:</span>
        <span class="n">funci</span> <span class="o">=</span> <span class="n">bounds2d</span> <span class="k">if</span> <span class="n">curvedi</span> <span class="k">else</span> <span class="n">bounds1d</span>
        <span class="n">loni</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funci</span><span class="p">(</span><span class="n">loni</span><span class="p">))</span>
        <span class="n">lati</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funci</span><span class="p">(</span><span class="n">lati</span><span class="p">))</span>
        <span class="n">funco</span> <span class="o">=</span> <span class="n">bounds2d</span> <span class="k">if</span> <span class="n">curvedo</span> <span class="k">else</span> <span class="n">bounds1d</span>
        <span class="n">lono</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funco</span><span class="p">(</span><span class="n">lono</span><span class="p">))</span>
        <span class="n">lato</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funco</span><span class="p">(</span><span class="n">lato</span><span class="p">))</span>

    <span class="c1"># Some checks about methods</span>
    <span class="k">if</span> <span class="n">curved</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_griddata_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;bining&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">_cdat_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="s1">&#39;Method not allowed with curvilinear grids: &#39;</span><span class="o">+</span><span class="n">method</span>
        <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">loni</span><span class="p">,</span> <span class="n">lati</span><span class="p">)</span>
    <span class="n">maskoext</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;krig&#39;</span><span class="p">:</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;carg&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="ow">or</span> \
        <span class="p">(</span><span class="n">check_mask</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;mixt&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bilinear_masking</span><span class="o">==</span><span class="s1">&#39;dstwgt&#39;</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">ext</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;carg&#39;</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># Needs nearest</span>
        <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">lono</span><span class="p">,</span> <span class="n">lato</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="n">curv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">loni</span><span class="p">,</span> <span class="n">lati</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">masking</span> <span class="k">import</span> <span class="n">grid_envelop_mask</span>
            <span class="n">maskoext</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">grid_envelop_mask</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="n">ext_masking</span><span class="o">==</span><span class="s2">&quot;poly&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bining&#39;</span> <span class="ow">and</span> <span class="n">curvedo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="s1">&#39;Method not allowed with curvilinear output grid: &#39;</span><span class="o">+</span><span class="n">method</span>

    <span class="c1"># 3D variable?</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vari3d</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="p">(</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span><span class="p">))</span>
        <span class="n">set_grid</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">ggi</span><span class="p">)</span>
<span class="c1">#        vari3d.getAxis(0).designateLevel() # hack against cdat bug</span>
        <span class="n">maski3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">maski</span><span class="p">,</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
<span class="c1">#        if vari.getOrder()[0] not in &#39;tz&#39;: # TODO: OPTIMIZE REGRID2</span>
<span class="c1">#            vari3d = vari.clone()</span>
<span class="c1">#            zaxis = vari3d.getAxis(0).clone()</span>
<span class="c1">#            zaxis.designateLevel()</span>
<span class="c1">#            vari3d.setAxis(0, zaxis)</span>
        <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari</span>
        <span class="n">maski3d</span> <span class="o">=</span> <span class="n">maski</span>

    <span class="c1"># Interpolations</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>

        <span class="c1"># Interpolation</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">_regrid2d_nearest2d_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">maskoext</span><span class="p">)</span>


    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">curved</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixt&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">])</span> <span class="ow">or</span> \
        <span class="p">(</span><span class="n">method</span><span class="o">==</span><span class="s1">&#39;bilinear&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">curved</span> <span class="ow">and</span> <span class="n">usecdr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">):</span>


        <span class="c1"># Method</span>
        <span class="n">wrapper</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_regrid2d_</span><span class="si">%s</span><span class="s1">_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># Interpolation</span>
        <span class="c1">#FIXME: wrapper pour dstwgt et mask... not sure</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="n">check_mask</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">bilinear_masking</span> <span class="o">==</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">:</span>
                <span class="n">masko</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">maski3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">:</span>
                    <span class="n">varo3d_dstwgt</span> <span class="o">=</span> <span class="n">_regrid2d_dstwgt_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">varo3d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">masko</span><span class="o">&lt;</span><span class="n">mask_thres</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">masko</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">),</span> <span class="n">varo3d_dstwgt</span><span class="p">,</span> <span class="n">varo3d</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">varo3d_dstwgt</span>
                <span class="n">varo3d</span><span class="p">[</span><span class="n">masko</span><span class="o">&gt;=</span><span class="n">mask_thres</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">masko</span> <span class="o">=</span> <span class="n">varo3d</span><span class="o">==</span><span class="n">mv</span>
                <span class="n">varo3d_nearest</span> <span class="o">=</span> <span class="n">_regrid2d_nearest2d_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span><span class="n">xxi</span><span class="p">,</span><span class="n">yyi</span><span class="p">,</span><span class="n">xxo</span><span class="p">,</span><span class="n">yyo</span><span class="p">,</span><span class="n">mv</span><span class="p">,</span><span class="n">geo</span><span class="p">,</span><span class="n">maskoext</span><span class="p">)</span>
                <span class="n">varo3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masko</span><span class="o">!=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">varo3d_nearest</span><span class="p">,</span> <span class="n">varo3d</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">varo3d_nearest</span>
            <span class="k">del</span> <span class="n">masko</span>



    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_cdat_methods</span><span class="p">:</span>

        <span class="c1"># Old regridder ?</span>
        <span class="k">if</span> <span class="n">useoldcdr</span> <span class="ow">or</span> <span class="n">useoldcdr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">curved</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cellave&#39;</span><span class="p">,</span> <span class="s1">&#39;conserv&#39;</span><span class="p">]:</span>

            <span class="n">tool</span> <span class="o">=</span> <span class="s1">&#39;regrid2&#39;</span>

        <span class="c1"># ESMF regridder</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">esmfcons</span> <span class="o">=</span> <span class="n">curved</span> <span class="c1">#and method in _cellave_methods</span>
            <span class="k">if</span> <span class="n">esmfcons</span><span class="p">:</span>
                <span class="n">check_mask</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">vari3d</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">maski3d</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">vari3d</span><span class="p">)</span>
                <span class="n">set_grid</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">ggi</span><span class="p">)</span>
            <span class="n">tool</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Regridder</span>
        <span class="k">if</span> <span class="n">cdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdr</span> <span class="o">=</span> <span class="n">CDATRegridder</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">ggor</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Regrid data</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">cdr</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">check_mask</span><span class="o">=</span><span class="n">check_mask</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">maski3d</span>

<span class="c1">#        # Masking</span>
<span class="c1">#        if check_mask:# and not method.startswith(&#39;cons&#39;):</span>
<span class="c1">#            good = vari3d.clone()</span>
<span class="c1">#            good[:] = 1-maski3d ;  del maski3d</span>
<span class="c1">#            goodo = cdr(good).filled(0.) ; del good</span>
<span class="c1">##           varo3d_nearest = _regrid2d_nearest2d_(vari3d.filled(mv),xxi,yyi,xxo,yyo,geo,maskoext,mv)</span>
<span class="c1">##           varo3d[:] = MV2.where(masko!=0., varo3d_nearest, varo3d)</span>
<span class="c1">#            varo3d[:] = MV2.masked_where((goodo&lt;0.9999), varo3d, copy=0) ; del goodo</span>
<span class="c1">##            varo3d[:] = MV2.masked_where((masko&gt;mask_thres).astype(&#39;b&#39;) &amp; (masko&gt;0.).astype(&#39;b&#39;), varo3d, copy=0)</span>
<span class="c1">##            del varo3d_nearest</span>



    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bin&#39;</span><span class="p">):</span>

        <span class="c1"># Interpolation</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">_regrid2d_bining_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="n">check_mask</span><span class="p">:</span>
            <span class="n">masko</span> <span class="o">=</span> <span class="n">_regrid2d_bining_</span><span class="p">(</span><span class="n">maski3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="n">varo3d</span><span class="p">[</span><span class="n">masko</span><span class="o">&gt;=</span><span class="n">mask_thres</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
            <span class="k">del</span> <span class="n">masko</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_griddata_methods</span><span class="p">:</span>

        <span class="c1"># Interpolation</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">_regrid2d_griddata_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="n">mv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Masking</span>
        <span class="k">if</span> <span class="n">check_mask</span><span class="p">:</span>
            <span class="n">masko</span> <span class="o">=</span> <span class="n">_regrid2d_griddata_</span><span class="p">(</span><span class="n">maski3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">missing_value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="c1">#           varo3d_nearest = _regrid2d_nearest2d_(vari3d.filled(mv),xxi,yyi,xxo,yyo,mv,geo,False)</span>
<span class="c1">#           varo3d = N.where(masko!=0., varo3d_nearest, varo3d)</span>
            <span class="n">varo3d</span><span class="p">[</span><span class="n">masko</span><span class="o">&gt;=</span><span class="n">mask_thres</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;carg&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ext</span><span class="p">:</span>
                <span class="n">varo3d</span><span class="p">[</span><span class="n">maskoext</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
<span class="c1">#           del varo3d_nearest</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s2">&quot;Well, what&#39;s this funckin&#39; method you bastard huh: </span><span class="si">%s</span><span class="s2">?&quot;</span><span class="o">%</span><span class="n">method</span>


    <span class="c1"># Back to rights dims</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">varo3d</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">vari3d</span><span class="p">,</span> <span class="n">varo3d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">varo3d</span>

    <span class="c1"># MV2 variable</span>
    <span class="n">varo</span><span class="p">[</span><span class="n">N</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">varo</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mv</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#   if not isgrid(ggo, curv=True):</span>
    <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">ggo</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iaxis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">))</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">getcdr</span><span class="p">:</span> <span class="k">return</span> <span class="n">varo</span><span class="p">,</span> <span class="n">cdr</span>
    <span class="k">return</span> <span class="n">varo</span></div>




<div class="viewcode-block" id="regrid2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid2d">[docs]</a><span class="k">def</span> <span class="nf">regrid2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rgdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">getrgdr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">erode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Regrid a variable from a regular grid to another</span>

<span class="sd">    If the input or output grid is curvilinear and ``method`` is set to</span>
<span class="sd">    ``&quot;linear&quot;``, ``&quot;cellave&quot;`` or ``&quot;conserv&quot;``, the :class:`CDATRegridder` is used.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **vari**: Variable cdms on regular grid</span>
<span class="sd">        - **ggo**: Tuple of (x,y) or a cdms grid or a cdms variable with a grid</span>
<span class="sd">        - **method**, optional: One of:</span>

<span class="sd">            - ``&quot;auto&quot;``: method guessed between ``linear`` and ``cellave``</span>
<span class="sd">              according to resolution of input and output grid (see :func:`regrid_method`)</span>
<span class="sd">            - ``&quot;nearest&quot;``: nearest neighbour</span>
<span class="sd">            - ``&quot;linear&quot;`` or ``&quot;bilinear&quot;``: bilinear interpolation (low res. to high res.)</span>
<span class="sd">            - ``&quot;dstwgt&quot;`` : distance weighting between the four nearest grid points</span>
<span class="sd">              (low res. to high res.)</span>
<span class="sd">            - ``&quot;patch&quot;`` : patch recovery interpolation (low res. to high res.)</span>
<span class="sd">            - ``&quot;cellave&quot;`` : weighted regridding based on areas of cells (high res. to low res.)</span>
<span class="sd">            - ``&quot;conserv&quot;`` : same as ``cell`` but conservative (high res. to low res.)</span>

<span class="sd">        - **tool**, optional: Regridder. One of:</span>

<span class="sd">            - ``&quot;auto&quot;``: tool guessed depending on the method, the first available tool</span>
<span class="sd">              and the grids (rectangular or curvilinear).</span>
<span class="sd">            - ``&quot;vacumm&quot;``: Internal routines.</span>
<span class="sd">            - ``&quot;esmf&quot;`` and ``&quot;libcf&quot;``: Regridders provided by UVCDAT.</span>
<span class="sd">            - ``&quot;regrid2&quot;``: Old regridder provided by CDAT (rectangular only).</span>

<span class="sd">        - **rgdr**, optional: An already set up regridder instance to speed up regridding:</span>
<span class="sd">          :class:`CDATRegridder` instance for ``regrid2``, ``esmf`` and ``libcf`` tools,</span>
<span class="sd">          else a :class:`CurvedInterpolator` instance for ``vacumm`` tool with</span>
<span class="sd">          interpolation on curvilinear grids.</span>
<span class="sd">        - **getrgdr**, optional: Also return the regridder instance if it applies, or None.</span>
<span class="sd">        - Other keywords are passed to special interpolation functions depending on method and choices :</span>

<span class="sd">            - :func:`cargen` when &quot;nat&quot; or &quot;carg&quot; method is used</span>

<span class="sd">    :Tools/methods:</span>

<span class="sd">        Overview table of method availability for each tool.</span>
<span class="sd">        ``RECT`` means that it only works with rectangular grids.</span>

<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        | Met/Tool | Vacumm | regrid2d | ESMF | Libcf |</span>
<span class="sd">        +==========+========+==========+======+=======+</span>
<span class="sd">        | nearest  |   OK   |          |      |       |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        | bilinear |   OK   |          |  OK  |  OK   |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        |  dstwgt  |   OK   |          |      |       |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        |  patch   |        |          |  OK  |       |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        | cellave  |        |   RECT   |  OK  |       |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>
<span class="sd">        | conserv  |        |   RECT   |  OK  |       |</span>
<span class="sd">        +----------+--------+----------+------+-------+</span>

<span class="sd">    :Examples:</span>

<span class="sd">        &gt;&gt;&gt; regrid2d(var, (lon, lat), method=&#39;linear&#39;)</span>
<span class="sd">        &gt;&gt;&gt; regrid2d(var, grid, method=&#39;cellave&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check grids</span>
    <span class="n">vari</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
    <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">N</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mv</span><span class="p">):</span>
        <span class="n">vari</span><span class="o">.</span><span class="n">setMissing</span><span class="p">(</span><span class="mf">1.e20</span><span class="p">)</span>
    <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">getMissing</span><span class="p">()</span>
    <span class="n">ggi</span> <span class="o">=</span> <span class="n">curv2rect</span><span class="p">(</span><span class="n">get_grid</span><span class="p">(</span><span class="n">vari</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">ggi</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nzi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">nxi</span><span class="o">*</span><span class="n">nyi</span><span class="p">)</span>
    <span class="n">ggo</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">ggo</span><span class="p">)</span>
    <span class="n">ggor</span> <span class="o">=</span> <span class="n">curv2rect</span><span class="p">(</span><span class="n">ggo</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span> <span class="o">=</span> <span class="n">ggo</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">loni</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lati</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lono</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggor</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lato</span> <span class="o">=</span> <span class="n">get_axis</span><span class="p">(</span><span class="n">ggor</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">lono</span><span class="p">[:]</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">lato</span><span class="p">[:]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">loni</span><span class="p">[:]</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">lati</span><span class="p">[:]</span>
    <span class="n">curvedi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span>
    <span class="n">curvedo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span>
    <span class="n">curved</span> <span class="o">=</span> <span class="n">curvedi</span> <span class="ow">or</span> <span class="n">curvedo</span>
    <span class="n">curvedio</span> <span class="o">=</span> <span class="n">curvedi</span> <span class="ow">and</span> <span class="n">curvedo</span>
    <span class="n">xxi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span class="c1">#    if geo is None:</span>
<span class="c1">#        geo = A.islon(loni) or A.islat(lati) or A.islon(lono) or A.islat(lato)</span>
    <span class="n">geo</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Method</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">regrid_method</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">))</span>
    <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;cellave&#39;</span><span class="p">,</span> <span class="s1">&#39;conserv&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">,</span> <span class="s1">&#39;patch&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Wrong regridding method: </span><span class="si">%s</span><span class="s1">. Please choose one of :&#39;</span><span class="o">%</span><span class="n">method</span><span class="o">+</span>
        <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_methods</span><span class="p">))</span>

    <span class="c1"># Tool verification</span>
    <span class="n">tool</span> <span class="o">=</span> <span class="n">regrid2d_tool_name</span><span class="p">(</span><span class="n">tool</span><span class="p">)</span>
    <span class="n">tools</span> <span class="o">=</span> <span class="n">regrid2_tools</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ttype</span> <span class="ow">in</span> <span class="s1">&#39;r2r&#39;</span><span class="p">,</span> <span class="s1">&#39;r2c&#39;</span><span class="p">,</span> <span class="s1">&#39;c2r&#39;</span><span class="p">,</span> <span class="s1">&#39;c2c&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ttype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tools</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span>  <span class="p">(</span><span class="n">ttype</span><span class="o">==</span><span class="s1">&#39;r2r&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">curved</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">ttype</span><span class="o">==</span><span class="s1">&#39;c2r&#39;</span> <span class="ow">and</span> <span class="n">curvedi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">curvedo</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">ttype</span><span class="o">==</span><span class="s1">&#39;r2c&#39;</span> <span class="ow">and</span> <span class="n">curvedo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">curvedi</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">ttype</span><span class="o">==</span><span class="s1">&#39;c2c&#39;</span><span class="p">:</span> <span class="c1"># Fall back | and curved):</span>
            <span class="k">if</span> <span class="n">tool</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">tool</span> <span class="o">=</span> <span class="n">tools</span><span class="p">[</span><span class="n">ttype</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># First available</span>
            <span class="k">elif</span> <span class="n">tool</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tools</span><span class="p">[</span><span class="n">ttype</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Tool </span><span class="si">%s</span><span class="s1"> not available for these grids and this method: &#39;</span><span class="o">%</span>
                    <span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;No suitable tool found for these grids and this method: &#39;</span><span class="o">+</span><span class="n">method</span><span class="p">)</span>

    <span class="c1"># Bounds</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">_cellave_methods</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">]:</span>
        <span class="n">funci</span> <span class="o">=</span> <span class="n">bounds2d</span> <span class="k">if</span> <span class="n">curvedi</span> <span class="k">else</span> <span class="n">bounds1d</span>
        <span class="n">loni</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funci</span><span class="p">(</span><span class="n">loni</span><span class="p">))</span>
        <span class="n">lati</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funci</span><span class="p">(</span><span class="n">lati</span><span class="p">))</span>
        <span class="n">funco</span> <span class="o">=</span> <span class="n">bounds2d</span> <span class="k">if</span> <span class="n">curvedo</span> <span class="k">else</span> <span class="n">bounds1d</span>
        <span class="n">lono</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funco</span><span class="p">(</span><span class="n">lono</span><span class="p">))</span>
        <span class="n">lato</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">funco</span><span class="p">(</span><span class="n">lato</span><span class="p">))</span>

    <span class="c1"># 2D arrays</span>
    <span class="k">if</span> <span class="n">curvedi</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">loni</span><span class="p">,</span> <span class="n">lati</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curvedi</span> <span class="ow">or</span> <span class="n">curvedo</span> <span class="ow">or</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">lono</span><span class="p">,</span> <span class="n">lato</span><span class="p">)</span>

    <span class="c1"># 3D variable?</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vari3d</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="p">(</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span><span class="p">))</span>
        <span class="n">set_grid</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">ggi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari</span>


    <span class="c1"># Interpolations !</span>
    <span class="n">rgdr</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">tool</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;regrid2&#39;</span><span class="p">,</span> <span class="s1">&#39;esmf&#39;</span><span class="p">,</span> <span class="s1">&#39;libcf&#39;</span><span class="p">]:</span>


<span class="c1">#        # ESMF regridder</span>
<span class="c1">#        if tool==&#39;esmf&#39; and method in [&quot;cellave&quot;, &quot;conserv&quot;]:</span>
<span class="c1">#            check_mask = True</span>
<span class="c1">#            vari3d = MV2.where(maski3d, 0., vari3d)</span>
<span class="c1">#            set_grid(vari3d, ggi)</span>
<span class="c1">#        else:</span>
<span class="c1">#            check_mask = False</span>

        <span class="c1"># Regridder</span>
        <span class="k">if</span> <span class="n">rgdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rgdr</span> <span class="o">=</span> <span class="n">CDATRegridder</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">ggor</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>

        <span class="c1"># Regrid data</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">rgdr</span><span class="p">(</span><span class="n">vari3d</span><span class="p">)</span><span class="c1">#, check_mask=check_mask)</span>
<span class="c1">#        del maski3d</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>

        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">_regrid2d_nearest2d_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">]:</span>

        <span class="k">if</span> <span class="n">curvedi</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_regrid2d_</span><span class="si">%s</span><span class="s1">_c2c_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>
            <span class="n">varo3d</span><span class="p">,</span> <span class="n">rgdr</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">rgdr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">curvedo</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_regrid2d_</span><span class="si">%s</span><span class="s1">_r2c_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>
            <span class="n">varo3d</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_regrid2d_</span><span class="si">%s</span><span class="s1">_r2r_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>
            <span class="n">varo3d</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">)</span>


    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;mixt&#39;</span><span class="p">]:</span>


        <span class="c1"># Method</span>
        <span class="n">wrapper</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_regrid2d_</span><span class="si">%s</span><span class="s1">_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># Interpolation</span>
        <span class="n">varo3d</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s2">&quot;Well, what&#39;s this funckin&#39; method you bastard huh: </span><span class="si">%s</span><span class="s2">?&quot;</span><span class="o">%</span><span class="n">method</span>


    <span class="c1"># Back to rights dims</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">MV</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">varo3d</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">vari3d</span><span class="p">,</span> <span class="n">varo3d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">varo3d</span>

    <span class="c1"># MV2 variable</span>
    <span class="n">varo</span><span class="p">[</span><span class="n">N</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">varo</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mv</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#   if not isgrid(ggo, curv=True):</span>
    <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">ggo</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iaxis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">,</span> <span class="n">vari</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">))</span>
    <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">getrgdr</span><span class="p">:</span> <span class="k">return</span> <span class="n">varo</span><span class="p">,</span> <span class="n">rgdr</span>
    <span class="k">return</span> <span class="n">varo</span></div>



<span class="n">regrid2dnew</span> <span class="o">=</span> <span class="n">regrid2d</span>

<span class="k">def</span> <span class="nf">_regrid2d_nearest2d_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">maskoext</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _nearest2d_&quot;&quot;&quot;</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xxi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="mi">50</span>
    <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">nb</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1">#    nb = -1</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_nearest2d_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="ow">not</span> <span class="n">geo</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">maskoext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">varo3d</span><span class="p">[</span><span class="n">maskoext</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<span class="k">def</span> <span class="nf">_regrid2d_bilinear_r2r_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin_&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_bilin_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="ow">not</span> <span class="n">geo</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">varo3d</span>
<span class="n">_regrid2d_bilinear_</span> <span class="o">=</span> <span class="n">_regrid2d_bilinear_r2r_</span>

<span class="k">def</span> <span class="nf">_regrid2d_bilinear_r2c_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin2dto1d_&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">_bilin2dto1d_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vari3d</span><span class="p">,</span> <span class="n">xxo</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yyo</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">mv</span><span class="p">))</span>
    <span class="n">varo3d</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">varo3d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xxo</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<span class="k">def</span> <span class="nf">_regrid2d_bilinear_c2c_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">rgdr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin2dto1dc_reduc_ through :class:`CurvedInterpolator`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rgdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rgdr</span> <span class="o">=</span> <span class="n">CurvedInterpolator</span><span class="p">((</span><span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">),</span> <span class="p">(</span><span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">),</span> <span class="n">g2g</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">rgdr</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">varo3d</span><span class="p">,</span> <span class="n">rgdr</span>

<span class="k">def</span> <span class="nf">_regrid2d_dstwgt_r2r_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin_&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_dstwgt_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="ow">not</span> <span class="n">geo</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">varo3d</span>
<span class="n">_regrid2d_dstwgt_</span> <span class="o">=</span> <span class="n">_regrid2d_dstwgt_r2r_</span>

<span class="k">def</span> <span class="nf">_regrid2d_dstwgt_r2c_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin2dto1d_&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">_dstwgt2dto1d_</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vari3d</span><span class="p">,</span> <span class="n">xxo</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yyo</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">mv</span><span class="p">))</span>
    <span class="n">varo3d</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">varo3d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">xxo</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<span class="k">def</span> <span class="nf">_regrid2d_dstwgt_c2c_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">rgdr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _bilin2dto1dc_reduc_ through :class:`CurvedInterpolator`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rgdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rgdr</span> <span class="o">=</span> <span class="n">CurvedInterpolator</span><span class="p">((</span><span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">),</span> <span class="p">(</span><span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">),</span> <span class="n">g2g</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span>  <span class="n">N</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">rgdr</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dstwgt&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">varo3d</span><span class="p">,</span> <span class="n">rgdr</span>


<span class="k">def</span> <span class="nf">_regrid2d_mixt_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">geo</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to fortran _mixt2dx_&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">vari3d</span><span class="p">):</span> <span class="n">vari3d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_mixt2dx_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span>  <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<span class="k">def</span> <span class="nf">_regrid2d_bining_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">mv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Regridding using rebining&quot;&quot;&quot;</span>
    <span class="n">xbins</span> <span class="o">=</span> <span class="n">meshcells</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
    <span class="n">ybins</span> <span class="o">=</span> <span class="n">meshcells</span><span class="p">(</span><span class="n">yo</span><span class="p">)</span>
    <span class="n">varo3d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yo</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xo</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vari2d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vari3d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vari2d</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">vari2d</span><span class="o">.</span><span class="n">mask</span>
            <span class="n">xc</span> <span class="o">=</span> <span class="n">xxi</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
            <span class="n">yc</span> <span class="o">=</span> <span class="n">yyi</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
            <span class="n">vartmp</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xc</span> <span class="o">=</span> <span class="n">xxi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">yc</span> <span class="o">=</span> <span class="n">yyi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">vartmp</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">yc</span><span class="p">,</span> <span class="n">xc</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">del</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span>
        <span class="n">count</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">(</span><span class="n">ybins</span><span class="p">,</span> <span class="n">xbins</span><span class="p">))</span> <span class="p">;</span> <span class="k">del</span> <span class="n">edges</span>
        <span class="n">varo3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">(</span><span class="n">ybins</span><span class="p">,</span> <span class="n">xbins</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">vartmp</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edges</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">count</span><span class="o">!=</span><span class="mi">0</span>
        <span class="n">varo3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">/=</span> <span class="n">count</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">varo3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">~</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv</span>
        <span class="k">del</span> <span class="n">good</span><span class="p">,</span> <span class="n">count</span>
    <span class="k">return</span> <span class="n">varo3d</span>


<span class="k">def</span> <span class="nf">_regrid2d_griddata_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to griddata&quot;&quot;&quot;</span>
    <span class="c1"># Good shapes</span>
    <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">nzi</span><span class="p">,</span> <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">vari2d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nxi</span><span class="o">*</span><span class="n">nyi</span><span class="p">)</span>
    <span class="c1"># Restrict zone</span>
    <span class="n">dxo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span>
    <span class="n">dyo</span> <span class="o">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span>
    <span class="c1">#if hasattr(vari2d, &#39;mask&#39;) and vari2d.mask is not MV2.nomask and vari2d.mask.any():</span>
        <span class="c1">#good = vari2d.mask</span>
    <span class="c1">#else:</span>
        <span class="c1">#good = N.zeros(vari2d.shape, &#39;?&#39;)</span>
    <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">xxi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">&gt;=</span><span class="p">(</span><span class="n">xo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dxo</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xxi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">xo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dxo</span><span class="p">))</span> <span class="o">&amp;</span> \
        <span class="p">(</span><span class="n">yyi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">&gt;=</span><span class="p">(</span><span class="n">yo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">dyo</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">yyi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">yo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">dyo</span><span class="p">))</span>
    <span class="n">varitmp</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xxitmp</span> <span class="o">=</span> <span class="n">xxi</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">yyitmp</span> <span class="o">=</span> <span class="n">yyi</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">del</span> <span class="n">vari2d</span>
    <span class="n">varo2d</span> <span class="o">=</span>  <span class="n">griddata</span><span class="p">(</span><span class="n">xxitmp</span><span class="p">,</span> <span class="n">yyitmp</span><span class="p">,</span> <span class="n">varitmp</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xo</span><span class="p">),</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yo</span><span class="p">)),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">xxitmp</span><span class="p">,</span> <span class="n">yyitmp</span><span class="p">,</span> <span class="n">varitmp</span>
    <span class="n">varo3d</span> <span class="o">=</span> <span class="n">varo2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">varo2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
    <span class="k">del</span> <span class="n">varo2d</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<span class="k">def</span> <span class="nf">_regrid2d_natgridlist_</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1">#FIXME: _regrid2d_natgridlist_ : missing values</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to Natgrid.nat with list output&quot;&quot;&quot;</span>
    <span class="c1"># Good shapes</span>
    <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">nzi</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span> <span class="o">=</span> <span class="n">xxo</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">vari2d</span> <span class="o">=</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">rehape</span><span class="p">(</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nxi</span><span class="o">*</span><span class="n">nyi</span><span class="p">)</span>
    <span class="c1"># Restrict zone</span>
    <span class="n">dxo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span>
    <span class="n">dyo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">/</span><span class="mf">10.</span>
    <span class="c1">#TODO: add dxo,dxy natgridlist in regrid2d</span>
    <span class="n">border</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xxo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yyo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">zip</span><span class="p">(</span><span class="n">xxo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yyo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>\
        <span class="nb">zip</span><span class="p">(</span><span class="n">xxo</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yyo</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="nb">zip</span><span class="p">(</span><span class="n">xxo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">yyo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">border</span><span class="p">))</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vari3d</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vari3d</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MV2</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">and</span> <span class="o">~</span><span class="n">vari3d</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">good</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">vari2d</span><span class="o">.</span><span class="n">mask</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nxi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nyi</span><span class="p">):</span>
            <span class="n">good</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">((</span><span class="n">xxi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">yyi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">varitmp</span> <span class="o">=</span> <span class="n">vari2d</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xxitmp</span> <span class="o">=</span> <span class="n">xxi</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">yyitmp</span> <span class="o">=</span> <span class="n">yyi</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">good</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">vari2d</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Natgrid</span><span class="p">(</span><span class="n">xxitmp</span><span class="p">,</span> <span class="n">yyitmp</span><span class="p">,</span> <span class="n">xo</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yo</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">listOutput</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">nul</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10.</span>
    <span class="n">r</span><span class="o">.</span><span class="n">dup</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">varo2d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nzi</span><span class="p">,</span> <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vari</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nzi</span><span class="p">):</span>
        <span class="n">varo2d</span><span class="p">[</span><span class="n">iz</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">rgrd</span><span class="p">(</span><span class="n">varitmp</span><span class="p">[</span><span class="n">iz</span><span class="p">])</span>
    <span class="k">del</span> <span class="n">xxitmp</span><span class="p">,</span> <span class="n">yyitmp</span><span class="p">,</span> <span class="n">varitmp</span>
    <span class="n">varo3d</span> <span class="o">=</span> <span class="n">varo2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vari3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">varo2d</span>
    <span class="k">return</span> <span class="n">varo3d</span>

<div class="viewcode-block" id="cellave2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.cellave2d">[docs]</a><span class="k">def</span> <span class="nf">cellave2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shortcut to :func:`regrid2d` call with ``method=&quot;cellave&quot;``&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cellave&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<span class="n">remap2d</span> <span class="o">=</span> <span class="n">cellave2d</span>

<div class="viewcode-block" id="interp2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.interp2d">[docs]</a><span class="k">def</span> <span class="nf">interp2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interp&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shortcut to :func:`regrid2d` call with ``method=&quot;interp&quot;`` by default&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">regrid2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ggo</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_isaxis_</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">var</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="regrid_method"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.regrid_method">[docs]</a><span class="k">def</span> <span class="nf">regrid_method</span><span class="p">(</span><span class="n">gridi</span><span class="p">,</span> <span class="n">grido</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=.</span><span class="mi">55</span><span class="p">,</span> <span class="n">iaxi</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iaxo</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess the best regridding method for passing from ``gridi`` to ``grido``</span>

<span class="sd">    If ``resolution(gridi) &lt;= ratio*resolution(grido)``, ``method=&quot;cellave&quot;``</span>
<span class="sd">    else  ``method=&quot;interp&quot;``</span>
<span class="sd">    The :func:`~vacumm.misc.grid.misc.resol` function is used to estimate</span>
<span class="sd">    the resolution.</span>
<span class="sd">    For grids, a resolution common to X and Y axes is estimated using the following</span>
<span class="sd">    sequence::</span>

<span class="sd">        xres, yres = resol(grid)</span>
<span class="sd">        res = (xres**2+yres**2)**.5</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **gridi**: Grid, tuple of axes or single axis or array.</span>
<span class="sd">        - **grido**: Grid, tuple of axes or single axis or array.</span>
<span class="sd">        - **ratio**, optional: Limit ratio of output grid resolution to input grid resolution.</span>
<span class="sd">        - **iaxi/iaxo**, optional: Dimension on which to compute the resolution with</span>
<span class="sd">          :func:`~vacumm.misc.grid.misc.resol` when ``gridi`` and ``grido`` are single axes</span>
<span class="sd">          with several dimensions.</span>

<span class="sd">    ..note::</span>

<span class="sd">        The resolution of the grids is checked in their attributes &quot;_xres&quot; and &quot;_yres&quot;</span>
<span class="sd">        before before trying to compute them.</span>

<span class="sd">    :Returns: ``&#39;cellave&#39;`` OR ``&#39;linear&#39;``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_isaxis_</span><span class="p">(</span><span class="n">gridi</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_isaxis_</span><span class="p">(</span><span class="n">grido</span><span class="p">):</span> <span class="c1"># Axes</span>

        <span class="n">resi</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="n">gridi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">iaxi</span><span class="p">)</span>
        <span class="n">reso</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="n">grido</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">iaxo</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># Grids</span>

        <span class="n">xresi</span><span class="p">,</span> <span class="n">yresi</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="n">gridi</span><span class="p">)</span>
        <span class="n">resi</span> <span class="o">=</span> <span class="p">(</span><span class="n">xresi</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">yresi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">xreso</span><span class="p">,</span> <span class="n">yreso</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="n">grido</span><span class="p">)</span>
        <span class="n">reso</span> <span class="o">=</span> <span class="p">(</span><span class="n">xreso</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">yreso</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>

    <span class="c1"># Check the ratio</span>
    <span class="k">return</span> <span class="s1">&#39;cellave&#39;</span> <span class="k">if</span> <span class="n">resi</span> <span class="o">&lt;=</span> <span class="n">ratio</span><span class="o">*</span><span class="n">reso</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span></div>


<div class="viewcode-block" id="GriddedMerger"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger">[docs]</a><span class="k">class</span> <span class="nc">GriddedMerger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge several gridded variables onto a grid</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **grid**: Output grid</span>
<span class="sd">        - **id**, optional: Output id</span>
<span class="sd">        - **long_name**, optional: Output long name</span>
<span class="sd">        - **units**, optional: Output units</span>
<span class="sd">        - Other keywords are set a output attributes</span>

<span class="sd">    :Example:</span>

<span class="sd">        &gt;&gt;&gt; gm = GriddedMerger(mygrid)</span>
<span class="sd">        &gt;&gt;&gt; gm += var1</span>
<span class="sd">        &gt;&gt;&gt; gm.append(var2)</span>
<span class="sd">        &gt;&gt;&gt; gm += var3</span>
<span class="sd">        &gt;&gt;&gt; gm -= var3</span>
<span class="sd">        &gt;&gt;&gt; gm.insert(0, var3)</span>
<span class="sd">        &gt;&gt;&gt; print len(gm)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; print gm</span>
<span class="sd">        ....</span>
<span class="sd">        &gt;&gt;&gt; myvar = gm.merge(res_ratio=.4, pad=3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">att</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">att</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="GriddedMerger.set_grid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.set_grid">[docs]</a>    <span class="k">def</span> <span class="nf">set_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the grid for merging&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xres</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yres</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="o">=</span> <span class="kc">None</span></div>
<div class="viewcode-block" id="GriddedMerger.get_grid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.get_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the grid for merging&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span></div>
<div class="viewcode-block" id="GriddedMerger.get_lon"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.get_lon">[docs]</a>    <span class="k">def</span> <span class="nf">get_lon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the longitudes of the grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>
<div class="viewcode-block" id="GriddedMerger.get_lat"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.get_lat">[docs]</a>    <span class="k">def</span> <span class="nf">get_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the loatitudes of the grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_load_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="c1"># Check grid</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Your variable must have a grid&#39;</span>
        <span class="c1"># Check dims</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">firstdims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_firstdims</span> <span class="o">==</span> <span class="n">firstdims</span><span class="p">,</span> <span class="s2">&quot;Incompatible number of dimension: </span><span class="si">%s</span><span class="s2">. It should be: </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span>\
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_firstdims</span><span class="p">,</span> <span class="n">firstdims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_firstaxes</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_firstdims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_firstaxes</span><span class="p">])</span>
        <span class="c1"># Method and resolution</span>
        <span class="n">var</span><span class="o">.</span><span class="n">_gm_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">_xres</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">_yres</span> <span class="o">=</span> <span class="n">resol</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="c1"># Bounds</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">bounds1d</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">var</span>
<div class="viewcode-block" id="GriddedMerger.add"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for :meth:`append`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="GriddedMerger.append"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append a bathymetry to the top of the merger&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load_</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>
    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
<div class="viewcode-block" id="GriddedMerger.remove"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">,</span> <span class="s1">&#39;Variable not in merger&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">var</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<div class="viewcode-block" id="GriddedMerger.insert"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_</span><span class="p">(</span><span class="n">var</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s1">&#39;No variables in the merger&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%i</span><span class="s1">) </span><span class="si">%s</span><span class="s1">_n&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="s1">&#39;long_name&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="s1">&#39;_gm_method&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">att</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">att</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="s1">&#39;_gm_xres&#39;</span><span class="p">,</span> <span class="s1">&#39;_gm_yres&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">(),</span> <span class="n">att</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">(),</span> <span class="n">att</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--</span><span class="se">\n</span><span class="s1">Total: </span><span class="si">%i</span><span class="s1"> variable(s)&#39;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="GriddedMerger.merge"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_ratio</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge all the variables on to a grid</span>


<span class="sd">        - **grid**: Out put grid or axes.</span>
<span class="sd">        - *res_ratio*: Resolution ratio for choosing between cell</span>
<span class="sd">          averaging and bilinear interpolation (see: :func:`regrid_method`).</span>
<span class="sd">        - *regrid_&lt;kwparam&gt;*: *&lt;kwparam&gt;* is passed to :func:`regrid2d` for interpolation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s1">&#39;You must add at least one variable to the merger&#39;</span>

        <span class="c1"># Some useful info if the output grid</span>
        <span class="n">lono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lon</span><span class="p">()</span>
        <span class="n">lato</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lat</span><span class="p">()</span>
        <span class="n">xbo</span> <span class="o">=</span> <span class="n">meshcells</span><span class="p">(</span><span class="n">lono</span><span class="p">)</span>
        <span class="n">ybo</span> <span class="o">=</span> <span class="n">meshcells</span><span class="p">(</span><span class="n">lato</span><span class="p">)</span>
        <span class="n">xbmino</span> <span class="o">=</span> <span class="n">xbo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">xbmaxo</span> <span class="o">=</span> <span class="n">xbo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">ybmino</span> <span class="o">=</span> <span class="n">ybo</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">ybmaxo</span> <span class="o">=</span> <span class="n">ybo</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid</span><span class="p">()</span>
        <span class="n">nyo</span><span class="p">,</span> <span class="n">nxo</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Inits</span>
        <span class="n">outmask2d</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_firstdims</span><span class="o">+</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="n">total_cover</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cover</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">wnd</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">vo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">kwregrid</span> <span class="o">=</span> <span class="n">kwfilter</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;regrid&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="c1"># Axes</span>
            <span class="n">loni</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getLongitude</span><span class="p">()</span> <span class="p">;</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">loni</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
            <span class="n">lati</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">()</span> <span class="p">;</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">lati</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
            <span class="n">nyi</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Guess the interpolation method</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">_gm_method</span> <span class="o">!=</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_gm_method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">regrid_method</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">(),</span> <span class="n">grid</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">res_ratio</span><span class="p">)</span>

            <span class="c1"># Guess the grid bounds according to the method</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;interp&#39;</span><span class="p">:</span>
                <span class="n">xmini</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">xmaxi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">ymini</span> <span class="o">=</span> <span class="n">yi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">ymaxi</span> <span class="o">=</span> <span class="n">yi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xmini</span> <span class="o">=</span> <span class="n">loni</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">xmaxi</span> <span class="o">=</span> <span class="n">loni</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">ymini</span> <span class="o">=</span> <span class="n">lati</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">ymaxi</span> <span class="o">=</span> <span class="n">lati</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># Cell covering</span>
            <span class="n">cover</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="c1"># - limits</span>
            <span class="k">if</span> <span class="n">xmini</span><span class="o">&gt;=</span><span class="n">xbmaxo</span> <span class="ow">or</span> <span class="n">xmaxi</span><span class="o">&lt;=</span><span class="n">xbmino</span> <span class="ow">or</span> \
                <span class="n">ymini</span><span class="o">&gt;=</span><span class="n">ybmaxo</span> <span class="ow">or</span> <span class="n">ymaxi</span><span class="o">&lt;=</span><span class="n">ybmino</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">ix0</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xbo</span><span class="p">,</span> <span class="n">xmini</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xbo</span><span class="p">,</span> <span class="n">xmaxi</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">iy0</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">ybo</span><span class="p">,</span> <span class="n">ymini</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">iy1</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">ybo</span><span class="p">,</span> <span class="n">ymaxi</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="c1"># - partial+full cells</span>
            <span class="n">cslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">iy0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iy1</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ix0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ix1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">cover</span><span class="p">[</span><span class="n">cslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cslice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="c1"># - partial cells</span>
            <span class="k">if</span> <span class="n">ix0</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">cover</span><span class="p">[:,</span> <span class="n">ix0</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xmini</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ix1</span><span class="o">&lt;</span><span class="n">nxo</span><span class="p">:</span>
                <span class="n">cover</span><span class="p">[:,</span> <span class="n">ix1</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">xmaxi</span><span class="o">-</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xbo</span><span class="p">[</span><span class="n">ix1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">iy0</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">cover</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ymini</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">iy1</span><span class="o">&lt;</span><span class="n">nyo</span><span class="p">:</span>
                <span class="n">cover</span><span class="p">[</span><span class="n">iy1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">ymaxi</span><span class="o">-</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ybo</span><span class="p">[</span><span class="n">iy1</span><span class="p">])</span>
            <span class="c1"># - borders</span>
            <span class="n">xpad</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nyo</span><span class="p">)</span>
            <span class="n">ypad</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nxo</span><span class="p">)</span>
            <span class="n">ipadmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ix1</span><span class="p">,</span> <span class="n">nxo</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ix0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ipad</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">ipadmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">xcov</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipad</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">xpad</span><span class="o">/</span><span class="p">(</span><span class="n">ipadmax</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">cover</span><span class="p">[:,</span> <span class="n">ipad</span><span class="p">]</span> <span class="o">*=</span> <span class="n">xcov</span>
                <span class="n">cover</span><span class="p">[:,</span> <span class="n">nxo</span><span class="o">-</span><span class="n">ipad</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">xcov</span>
                <span class="k">del</span> <span class="n">xcov</span>
            <span class="n">jpadmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">iy1</span><span class="p">,</span> <span class="n">nyo</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">iy0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">jpad</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">jpadmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">ycov</span> <span class="o">=</span> <span class="p">(</span><span class="n">jpad</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">ypad</span><span class="o">/</span><span class="p">(</span><span class="n">jpadmax</span><span class="o">+.</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">cover</span><span class="p">[</span><span class="n">jpad</span><span class="p">]</span> <span class="o">*=</span> <span class="n">ycov</span>
                <span class="n">cover</span><span class="p">[</span><span class="n">nyo</span><span class="o">-</span><span class="n">jpad</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">ycov</span>
                <span class="k">del</span> <span class="n">ycov</span>
            <span class="k">del</span> <span class="n">xpad</span><span class="p">,</span> <span class="n">ypad</span>

            <span class="c1"># Regridding</span>
            <span class="n">vo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">regrid2d</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwregrid</span><span class="p">)</span>

            <span class="c1"># Contribution to varo</span>
            <span class="n">cover</span><span class="p">[</span><span class="n">total_cover</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">total_cover</span> <span class="o">+=</span> <span class="n">cover</span>
            <span class="n">wnd</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">vo</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">wnd</span>
            <span class="n">varo</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cslice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vo</span><span class="p">[</span><span class="n">cslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cslice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">total_cover</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="n">varo</span><span class="o">/</span><span class="n">total_cover</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">,</span> <span class="n">cover</span><span class="p">,</span> <span class="n">total_cover</span><span class="p">,</span> <span class="n">vo</span><span class="p">,</span> <span class="n">wnd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="o">=</span> <span class="n">varo</span>
        <span class="k">return</span> <span class="n">varo</span></div>

<div class="viewcode-block" id="GriddedMerger.plot"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.GriddedMerger.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge and plot&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">...plot</span> <span class="k">import</span> <span class="n">map2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">map2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_shiftslicenames_</span><span class="p">(</span><span class="n">shift</span><span class="p">):</span>
     <span class="k">if</span> <span class="n">shift</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">firsts</span> <span class="o">=</span> <span class="s1">&#39;firsts&#39;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span>
        <span class="n">oppos</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="n">neigh1</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span>
        <span class="n">neigh2</span> <span class="o">=</span> <span class="s1">&#39;lastm1&#39;</span>
        <span class="n">firsts</span> <span class="o">=</span> <span class="s1">&#39;firsts&#39;</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="s1">&#39;lasts&#39;</span>
     <span class="k">else</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">firsts</span> <span class="o">=</span> <span class="s1">&#39;lasts&#39;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="n">oppos</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span>
        <span class="n">neigh1</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="n">neigh2</span> <span class="o">=</span> <span class="s1">&#39;firstp1&#39;</span>
        <span class="n">firsts</span> <span class="o">=</span> <span class="s1">&#39;lasts&#39;</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="s1">&#39;firsts&#39;</span>
     <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">oppos</span><span class="o">=</span><span class="n">oppos</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="n">last</span><span class="p">,</span>
        <span class="n">neigh1</span><span class="o">=</span><span class="n">neigh1</span><span class="p">,</span> <span class="n">neigh2</span><span class="o">=</span><span class="n">neigh2</span><span class="p">,</span> <span class="n">firsts</span><span class="o">=</span><span class="n">firsts</span><span class="p">,</span> <span class="n">lasts</span><span class="o">=</span><span class="n">lasts</span><span class="p">)</span>


<div class="viewcode-block" id="shift1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.shift1d">[docs]</a><span class="k">def</span> <span class="nf">shift1d</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shiftaxis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate data on an axis shifted by an half cell size</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **var**: array.</span>
<span class="sd">        - **shift**, optional: Shift to operate.</span>

<span class="sd">            - ``0``: No shift.</span>
<span class="sd">            - ``&lt;0``: Shilt toward bottom of the axis.</span>
<span class="sd">            - ``&gt;0``: Shilt toward top of the axis.</span>

<span class="sd">        - **bmode**, optional: Boundary mode.</span>

<span class="sd">            - ``None``: ``&quot;extrap&quot;`` if axis else ``&quot;same&quot;``</span>
<span class="sd">            - ``&quot;linear&quot;``: Linear extrapolation.</span>
<span class="sd">            - ``&quot;same&quot;``: Constant extrapolation.</span>
<span class="sd">            - ``&quot;masked&quot;``: Mask outside data.</span>
<span class="sd">            - ``&quot;cyclic&quot;``: Cyclic extrapolation.</span>

<span class="sd">        - **axis**, optional: Axis on which to operate.</span>
<span class="sd">        - **copy**, optional: Always input copy data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input data</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;clone&#39;</span><span class="p">):</span>
            <span class="n">varo</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varo</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">var</span>
    <span class="k">if</span> <span class="n">shift</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">varo</span>
    <span class="k">if</span> <span class="n">shift</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">bmode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="n">bmode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bmode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bmode</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span> <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;same&quot;</span>
    <span class="k">elif</span> <span class="n">bmode</span><span class="o">==</span><span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
        <span class="n">bmode</span> <span class="o">=</span> <span class="s2">&quot;same&quot;</span>
    <span class="k">elif</span> <span class="n">bmode</span><span class="o">==</span><span class="s1">&#39;extrap&#39;</span><span class="p">:</span>
        <span class="n">bmode</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span><span class="p">:</span>
        <span class="n">varf</span> <span class="o">=</span> <span class="n">varo</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varf</span> <span class="o">=</span> <span class="n">varo</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">varo</span><span class="p">):</span>
        <span class="n">refvar</span> <span class="o">=</span> <span class="n">varo</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shiftaxis</span><span class="p">:</span>
            <span class="n">xo</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">shift</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="s1">&#39;extrap&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">refvar</span> <span class="o">=</span> <span class="n">varf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Get slice specs</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">get_axis_slices</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">sn</span> <span class="o">=</span> <span class="n">_shiftslicenames_</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>

    <span class="c1"># Inner data</span>
    <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;firsts&#39;</span><span class="p">]]</span><span class="o">+</span><span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;lasts&#39;</span><span class="p">]])</span><span class="o">*</span><span class="mf">0.5</span>

    <span class="c1"># Boundary data</span>
    <span class="k">if</span> <span class="n">bmode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span><span class="p">:</span>
        <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="k">elif</span> <span class="n">bmode</span><span class="o">==</span><span class="s1">&#39;cyclic&#39;</span><span class="p">:</span>
        <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;oppos&#39;</span><span class="p">]]]</span>
    <span class="k">elif</span> <span class="n">bmode</span><span class="o">==</span><span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;neigh1&#39;</span><span class="p">]]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;neigh1&#39;</span><span class="p">]]]</span>
        <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]]]</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;neigh1&#39;</span><span class="p">]]]</span><span class="o">-</span><span class="n">refvar</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="n">sn</span><span class="p">[</span><span class="s1">&#39;neigh2&#39;</span><span class="p">]]])</span>
    <span class="k">del</span> <span class="n">refvar</span>

    <span class="c1"># Axes</span>
    <span class="k">if</span> <span class="n">ax</span><span class="p">:</span>
        <span class="n">varo</span><span class="o">.</span><span class="n">assignValue</span><span class="p">(</span><span class="n">varf</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">xo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">xo</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">varo</span></div>

<div class="viewcode-block" id="shift2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.shift2d">[docs]</a><span class="k">def</span> <span class="nf">shift2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ishift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jshift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate data on an grid shifted by an half cell size in X and Y</span>

<span class="sd">    X and Y are supposed to be the -1 and -2 axes of var.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **var**: array.</span>
<span class="sd">        - **[i/j]shift**, optional: Shift to operate along X/Y.</span>

<span class="sd">            - ``0``: No shift.</span>
<span class="sd">            - ``&lt;0``: Shilt toward bottom of the axis.</span>
<span class="sd">            - ``&gt;0``: Shilt toward top of the axis.</span>

<span class="sd">        - **bmode**, optional: Boundary mode.</span>

<span class="sd">            - ``&quot;linear&quot;``: Linear extrapolation.</span>
<span class="sd">            - ``&quot;same&quot;``: Constant extrapolation.</span>
<span class="sd">            - ``&quot;masked&quot;``: Mask outside data.</span>
<span class="sd">            - ``&quot;cyclic&quot;``: Cyclic extrapolation.</span>

<span class="sd">        - **copy**, optional: Always input copy data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="s1">&#39;clone&#39;</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">vari</span>
    <span class="k">if</span> <span class="n">ishift</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">jshift</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">var</span>
    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ne</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">sg</span><span class="p">:</span>
        <span class="n">grido</span> <span class="o">=</span> <span class="n">shiftgrid</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">(),</span> <span class="n">ishift</span><span class="o">=</span><span class="n">ishift</span><span class="p">,</span> <span class="n">jshift</span><span class="o">=</span><span class="n">jshift</span><span class="p">)</span>
    <span class="n">bmode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="n">bmode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bmode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>


    <span class="c1"># Slices</span>
    <span class="n">ssx</span> <span class="o">=</span> <span class="n">get_axis_slices</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">snx</span> <span class="o">=</span> <span class="n">_shiftslicenames_</span><span class="p">(</span><span class="n">ishift</span><span class="p">)</span>
    <span class="n">ssy</span> <span class="o">=</span> <span class="n">get_axis_slices</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sny</span> <span class="o">=</span> <span class="n">_shiftslicenames_</span><span class="p">(</span><span class="n">jshift</span><span class="p">)</span>

    <span class="c1"># Shift along X only</span>
    <span class="n">kwxshift</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="n">bmode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span> <span class="ow">or</span> <span class="n">jshift</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shiftaxis</span><span class="o">=</span><span class="ow">not</span> <span class="n">sg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">jshift</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">ishift</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">varx</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ishift</span><span class="p">,</span> <span class="o">**</span><span class="n">kwxshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jshift</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sg</span><span class="p">:</span>
                <span class="n">set_grid</span><span class="p">(</span><span class="n">varx</span><span class="p">,</span> <span class="n">grido</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">varx</span>

    <span class="c1"># Shift along Y only</span>
    <span class="n">kwyshift</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">bmode</span> <span class="o">=</span> <span class="n">bmode</span> <span class="k">if</span> <span class="n">bmode</span><span class="o">!=</span><span class="s1">&#39;cyclic&#39;</span> <span class="k">else</span> <span class="s1">&#39;extrap&#39;</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span> <span class="ow">or</span> <span class="n">ishift</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shiftaxis</span><span class="o">=</span><span class="ow">not</span> <span class="n">sg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ishift</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">jshift</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">vary</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">jshift</span><span class="p">,</span> <span class="o">**</span><span class="n">kwyshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ishift</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sg</span><span class="p">:</span>
                <span class="n">set_grid</span><span class="p">(</span><span class="n">vary</span><span class="p">,</span> <span class="n">grido</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vary</span>

    <span class="c1"># Inner Y</span>
    <span class="n">var</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
    <span class="n">var</span><span class="p">[</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;firsts&#39;</span><span class="p">]]]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">varx</span><span class="p">[</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;firsts&#39;</span><span class="p">]]]</span><span class="o">+</span><span class="n">varx</span><span class="p">[</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;lasts&#39;</span><span class="p">]]])</span>

    <span class="c1"># Top Y</span>
    <span class="n">sstopyfirsts</span> <span class="o">=</span> <span class="n">merge_axis_slice</span><span class="p">(</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]],</span> <span class="n">ssx</span><span class="p">[</span><span class="n">snx</span><span class="p">[</span><span class="s1">&#39;firsts&#39;</span><span class="p">]])</span>
    <span class="n">sstopylasts</span> <span class="o">=</span> <span class="n">merge_axis_slice</span><span class="p">(</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]],</span> <span class="n">ssx</span><span class="p">[</span><span class="n">snx</span><span class="p">[</span><span class="s1">&#39;lasts&#39;</span><span class="p">]])</span>
    <span class="n">var</span><span class="p">[</span><span class="n">sstopyfirsts</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">vary</span><span class="p">[</span><span class="n">sstopyfirsts</span><span class="p">]</span><span class="o">+</span><span class="n">vary</span><span class="p">[</span><span class="n">sstopylasts</span><span class="p">])</span>

    <span class="c1"># Shift along X and Y</span>
    <span class="n">sslast</span> <span class="o">=</span> <span class="n">merge_axis_slice</span><span class="p">(</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]],</span> <span class="n">ssx</span><span class="p">[</span><span class="n">snx</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]])</span>
    <span class="n">sslastxy</span> <span class="o">=</span> <span class="n">get_axis_slices</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sslastx</span> <span class="o">=</span> <span class="n">sslastxy</span><span class="p">[</span><span class="n">snx</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]</span>
    <span class="n">sslasty</span> <span class="o">=</span> <span class="n">sslastxy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]</span>
    <span class="n">varlastx</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">varx</span><span class="p">[</span><span class="n">ssx</span><span class="p">[</span><span class="n">snx</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]],</span> <span class="n">ishift</span><span class="p">,</span> <span class="o">**</span><span class="n">kwxshift</span><span class="p">)</span> <span class="c1">#; del varx</span>
    <span class="n">var</span><span class="p">[</span><span class="n">sslast</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">varlastx</span><span class="p">[</span><span class="n">sslastx</span><span class="p">]</span> <span class="c1">#; del varlastx</span>
    <span class="n">kwyshift</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">varlasty</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">vary</span><span class="p">[</span><span class="n">ssy</span><span class="p">[</span><span class="n">sny</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]],</span> <span class="n">jshift</span><span class="p">,</span> <span class="o">**</span><span class="n">kwyshift</span><span class="p">)</span> <span class="c1">#; del vary</span>
    <span class="n">var</span><span class="p">[</span><span class="n">sslast</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">varlasty</span><span class="p">[</span><span class="n">sslasty</span><span class="p">]</span> <span class="c1">#; del varlastx</span>

    <span class="c1"># Grid for MV2 arrays</span>
    <span class="k">if</span> <span class="n">sg</span><span class="p">:</span>
        <span class="n">set_grid</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">grido</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">var</span></div>


<div class="viewcode-block" id="shiftgrid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.shiftgrid">[docs]</a><span class="k">def</span> <span class="nf">shiftgrid</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">ishift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jshift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shift a grid of an half cell</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **gg**: cdms2 grid.</span>
<span class="sd">        - **i/jshift**: Fraction cell to shift.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">get_xy</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
    <span class="n">bmode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="n">bmode</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">shift2d</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">ishift</span><span class="o">=</span><span class="n">ishift</span><span class="p">,</span> <span class="n">jshift</span><span class="o">=</span><span class="n">jshift</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="n">bmode</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">shift2d</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">ishift</span><span class="o">=</span><span class="n">ishift</span><span class="p">,</span> <span class="n">jshift</span><span class="o">=</span><span class="n">jshift</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="n">bmode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">ishift</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="n">bmode</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">shift1d</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">jshift</span><span class="p">,</span> <span class="n">bmode</span><span class="o">=</span><span class="n">bmode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">gg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span></div>

<span class="k">def</span> <span class="nf">_extend_init_</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Some inits for extend1d and extend2d&quot;&quot;&quot;</span>
    <span class="c1"># In and out data</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="s1">&#39;axis&#39;</span>
        <span class="n">varm</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="s1">&#39;axis1d&#39;</span>
            <span class="n">varf</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="s1">&#39;axis2d&#39;</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span> <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span> <span class="k">else</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span>
            <span class="n">varf</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
        <span class="n">varm</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span>
        <span class="n">varf</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="s1">&#39;mv&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">datatype</span> <span class="o">=</span> <span class="s1">&#39;ma&#39;</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span> <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMA</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span> <span class="k">else</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span>
        <span class="n">varm</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">varf</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

    <span class="c1"># Extrapolation mode</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;extrap&quot;</span> <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">isaxis</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;same&quot;</span>
    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;same&quot;</span>
    <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;extrap&#39;</span>

    <span class="k">return</span> <span class="n">varm</span><span class="p">,</span> <span class="n">varf</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">mode</span>

<div class="viewcode-block" id="extend1d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.extend1d">[docs]</a><span class="k">def</span> <span class="nf">extend1d</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extrapolate data on an axis</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **var**: Array.</span>
<span class="sd">        - **ext**, optional: Size of extension. If a tuple,</span>
<span class="sd">          it gives left and right extensions, else the same</span>
<span class="sd">          for both.</span>

<span class="sd">        - **mode**, optional: Interpolation mode for boundary point outside initial positions.</span>

<span class="sd">            - ``None``: ``&quot;extrap&quot;`` if axis else ``&quot;same&quot;``</span>
<span class="sd">            - ``&quot;extrap&quot;`` or ``&quot;linear&quot;``: Linear extrapolation.</span>
<span class="sd">            - ``&quot;same&quot;``: Constant extrapolation.</span>
<span class="sd">            - ``&quot;cyclic&quot;``: Cyclic extrapolation.</span>
<span class="sd">            - ``&quot;masked&quot;``: Masked.</span>

<span class="sd">        - **axis**, optional: Axis on which to operate.</span>
<span class="sd">        - **copy**, optional: Always input copy data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Size of extension</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span> <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;clone&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="c1"># Data and mode</span>
    <span class="n">varo_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varo_shape</span><span class="p">)</span><span class="o">+</span><span class="n">axis</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">varo_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">no</span> <span class="o">=</span> <span class="n">ni</span><span class="o">+</span><span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">varo_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">no</span>
    <span class="n">varm</span><span class="p">,</span> <span class="n">varf</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">_extend_init_</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">varo_shape</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Get slice specs</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">get_axis_slices</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">extinner</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">extleft</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">extright_for_left</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">extright</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span> <span class="n">extleft_for_right</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="c1"># Unchanged data</span>
    <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extinner&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">varm</span>

    <span class="c1"># Left boundary</span>
    <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span><span class="p">:</span>
            <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;cylic&#39;</span><span class="p">:</span>
            <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright_for_left&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;extrap&#39;</span><span class="p">:</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]]</span><span class="o">-</span><span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;firstp1&#39;</span><span class="p">]]</span>
            <span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">i</span>
                <span class="n">varf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">])]</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;extrap&#39;</span><span class="p">:</span>
                    <span class="n">varf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft&#39;</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">i</span><span class="o">*</span><span class="n">dv</span>

    <span class="c1"># Right boundary</span>
    <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;masked&#39;</span><span class="p">:</span>
            <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;cylic&#39;</span><span class="p">:</span>
            <span class="n">varf</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extleft_for_right&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;extrap&#39;</span><span class="p">:</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]</span><span class="o">-</span><span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;lastm1&#39;</span><span class="p">]]</span>
            <span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ni</span><span class="o">+</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">varf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">])]</span> <span class="o">=</span> <span class="n">varm</span><span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;extrap&#39;</span><span class="p">:</span>
                    <span class="n">varf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="s1">&#39;extright&#39;</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">i</span><span class="o">*</span><span class="n">dv</span>
    <span class="k">del</span> <span class="n">varm</span>

    <span class="c1"># Format</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">num</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">datatype</span><span class="o">==</span><span class="s1">&#39;axis1d&#39;</span><span class="p">:</span>

            <span class="n">varo</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">varf</span><span class="p">)</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">varo</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">datatype</span><span class="o">==</span><span class="s1">&#39;axis2d&#39;</span><span class="p">:</span>

            <span class="n">varo</span> <span class="o">=</span> <span class="n">create_axes2d</span><span class="p">(</span><span class="n">varf</span><span class="p">)</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">varo</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iaxis</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cp_atts</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">),</span> <span class="n">varo</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">datatype</span><span class="o">==</span><span class="s1">&#39;mv&#39;</span><span class="p">:</span>

            <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">varf</span><span class="p">)</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">varo</span><span class="p">)</span>
            <span class="n">gridi</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">iaxis</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">varo</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="n">axi</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">getAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">axis</span><span class="o">!=</span><span class="n">iaxis</span><span class="p">:</span>
                    <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">iaxis</span><span class="p">,</span> <span class="n">axi</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">gridi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">axo</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;extrap&#39;</span><span class="p">)</span>
                    <span class="n">cp_atts</span><span class="p">(</span><span class="n">axi</span><span class="p">,</span> <span class="n">axo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gridi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">axis</span><span class="o">&gt;=</span><span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">iext</span> <span class="o">=</span> <span class="n">ext</span> <span class="k">if</span> <span class="n">axis</span><span class="o">==</span><span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">jext</span> <span class="o">=</span> <span class="n">ext</span> <span class="k">if</span> <span class="n">axis</span><span class="o">==</span><span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">grido</span> <span class="o">=</span> <span class="n">extendgrid</span><span class="p">(</span><span class="n">gridi</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="n">jext</span><span class="p">)</span>
                    <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">extendgrid</span><span class="p">(</span><span class="n">gridi</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="n">jext</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">gridi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varo</span> <span class="o">=</span> <span class="n">varf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">varf</span>

    <span class="k">return</span> <span class="n">varo</span></div>

<div class="viewcode-block" id="extend2d"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.extend2d">[docs]</a><span class="k">def</span> <span class="nf">extend2d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate data on an grid shifted by an half cell size in X and Y</span>

<span class="sd">    X and Y are supposed to be the -1 and -2 axes of var.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **var**: Array.</span>
<span class="sd">        - **i/jext**, optional: Size of extension along i/j.</span>
<span class="sd">          If a tuple,it gives left and right extensions, else the same</span>
<span class="sd">          for both.</span>

<span class="sd">        - **mode**, optional: Interpolation mode for boundary point outside initial positions.</span>

<span class="sd">            - ``None``: ``&quot;extrap&quot;`` if axis else ``&quot;same&quot;``</span>
<span class="sd">            - ``&quot;extrap&quot;`` or ``&quot;linear&quot;``: Linear extrapolation.</span>
<span class="sd">            - ``&quot;same&quot;``: Constant extrapolation.</span>
<span class="sd">            - ``&quot;masked&quot;``: Masked.</span>

<span class="sd">        - **copy**, optional: Always input copy data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Size of extensions</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iext</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">iext</span> <span class="o">=</span> <span class="p">(</span><span class="n">iext</span><span class="p">,</span> <span class="n">iext</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jext</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">jext</span> <span class="o">=</span> <span class="p">(</span><span class="n">jext</span><span class="p">,</span> <span class="n">jext</span><span class="p">)</span>

    <span class="c1"># No extension</span>
    <span class="k">if</span> <span class="n">iext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">iext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">jext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">jext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span> <span class="k">return</span> <span class="n">vari</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="s1">&#39;clone&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">vari</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vari</span>

    <span class="c1"># Single axis</span>
    <span class="k">if</span> <span class="n">iext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">iext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">jext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">jext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">jext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="c1"># X then Y</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">jext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Merge with Y then X</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">jext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">varo</span> <span class="o">+=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">tmp</span>
    <span class="n">varo</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mf">0.5</span>


    <span class="k">return</span> <span class="n">varo</span></div>

<div class="viewcode-block" id="extendgrid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.extendgrid">[docs]</a><span class="k">def</span> <span class="nf">extendgrid</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;extrap&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extrapolate a grid</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **gg**: cdms2 grid.</span>
<span class="sd">        - **i/jext**: Size of extrapolation along i/j.</span>
<span class="sd">        - **mode**, optional: Interpolation mode for boundary point outside initial positions.</span>

<span class="sd">            - ``&quot;extrap&quot;``: Linear extrapolation.</span>
<span class="sd">            - ``&quot;same&quot;``: Constant extrapolation.</span>
<span class="sd">            - ``&quot;masked&quot;``: Masked.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">get_xy</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">extend2d</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="n">jext</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">extend2d</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">iext</span><span class="o">=</span><span class="n">iext</span><span class="p">,</span> <span class="n">jext</span><span class="o">=</span><span class="n">jext</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">iext</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">extend1d</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">jext</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">gg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">create_grid</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span></div>


<div class="viewcode-block" id="CDATRegridder"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.CDATRegridder">[docs]</a><span class="k">class</span> <span class="nc">CDATRegridder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Regridding using CDAT regridders</span>

<span class="sd">    .. note:: This code is adapted from the :meth:`regrid` method of MV2 arrays.</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **fromgrid**: Input grid, or variable with a grid.</span>
<span class="sd">        - **togrid**: Output grid.</span>
<span class="sd">        - **tool**, optional: One of ``&quot;esmf&quot;``, ``&quot;libcf&quot;`` and ``&quot;regrid2&quot;``.</span>
<span class="sd">        - **method**, optional: One of ``&quot;linear&quot;``, ``&quot;path&quot;``, ``&quot;conservative&quot;`` and ``&quot;cellave&quot;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromgrid</span><span class="p">,</span> <span class="n">togrid</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">fromgrid</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">fromgrid</span><span class="p">):</span>
            <span class="n">fromvar</span> <span class="o">=</span> <span class="n">fromgrid</span>
            <span class="n">fromgrid</span> <span class="o">=</span> <span class="n">fromvar</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fromvar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Verify bounds</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">fromgrid</span><span class="p">,</span> <span class="n">togrid</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">getLongitude</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">xy</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">bounds1d</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="n">bounds2d</span>
                    <span class="n">xy</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span>

        <span class="c1"># Curved?</span>
        <span class="n">curved</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromgrid</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">togrid</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="c1"># Default</span>
        <span class="n">regridTool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

<span class="c1">#        # Some keywords for longitudes</span>
<span class="c1">#        for lon in fromgrid.getAxis(-1), fromgrid.getLongitude():</span>
<span class="c1">#            if lon.attributes.get(&#39;topology&#39;,  None) == &#39;circular&#39;:</span>
<span class="c1">#                keywords[&#39;periodicity&#39;] = 1 # for the ESMF regridders</span>
<span class="c1">#                keywords[&#39;mkCyclic&#39;] = 1    # for LibCF regridder</span>
<span class="c1">#                break</span>

        <span class="c1"># User request</span>
        <span class="c1"># - method</span>
        <span class="n">userSpecifiesMethod</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="s1">&#39;rm&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;regridmethod&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid_method&#39;</span><span class="p">,</span> <span class="s1">&#39;regridMethod&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keywords</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">rm</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rm</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">regridMethod</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rm</span><span class="p">]</span>
                    <span class="n">userSpecifiesMethod</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rm</span><span class="p">]</span>
        <span class="c1"># - tool</span>
        <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="s1">&#39;tool&#39;</span><span class="p">,</span> <span class="s1">&#39;regridtool&#39;</span><span class="p">,</span> <span class="s1">&#39;regrid_tool&#39;</span><span class="p">,</span> <span class="s1">&#39;regridTool&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keywords</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">rt</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">regridTool</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">keywords</span><span class="p">[</span><span class="n">rt</span><span class="p">]</span>

        <span class="c1"># The method and grid determine the tool</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^(cons|cell)&#39;</span><span class="p">,</span> <span class="n">regridMethod</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
            <span class="n">regridTool</span> <span class="o">=</span> <span class="s1">&#39;esmf&#39;</span>
        <span class="k">elif</span> <span class="n">regridTool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curved</span><span class="p">:</span>
                <span class="n">regridTool</span> <span class="o">=</span> <span class="s1">&#39;regrid2&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">regridTool</span> <span class="o">=</span> <span class="s1">&#39;esmf&#39;</span>

        <span class="c1"># Make sure the tool can do it</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^regrid&#39;</span><span class="p">,</span> <span class="n">regridTool</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span> <span class="ow">and</span> <span class="n">curved</span><span class="p">:</span>
            <span class="n">regridTool</span> <span class="o">=</span> <span class="s1">&#39;esmf&#39;</span>

        <span class="c1"># Clean regrid tool names</span>
        <span class="n">regridTool</span> <span class="o">=</span> <span class="n">regrid2d_tool_name</span><span class="p">(</span><span class="n">regridTool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tool</span> <span class="o">=</span> <span class="n">regridTool</span>

        <span class="c1"># Conservative versus cellave</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weidstfracs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mskdstfracs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;esmf&#39;</span><span class="p">,</span><span class="n">regridTool</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(cons|cell)&#39;</span><span class="p">,</span> <span class="n">regridMethod</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">regridMethod</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
                <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;conservative&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weidstfracs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mskdstfracs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^regrid&#39;</span><span class="p">,</span><span class="n">regridTool</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">regridMethod</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
                <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;conservative&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weidstfracs</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_divdstfracs</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Clean method names</span>
        <span class="n">regridMethod</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">regridMethod</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regridMethod</span><span class="o">==</span><span class="s1">&#39;bilinear&#39;</span><span class="p">:</span>
            <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;patch&#39;</span><span class="p">,</span><span class="n">regridMethod</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
            <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;patch&#39;</span>
        <span class="k">elif</span> <span class="n">regridMethod</span><span class="o">==</span><span class="s1">&#39;conserv&#39;</span><span class="p">:</span>
            <span class="n">regridMethod</span> <span class="o">=</span> <span class="s1">&#39;conservative&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Wrong CDATRegridder regrid method. Please one of: &#39;</span><span class="o">+</span>
                <span class="s1">&#39;linear, conserv, patch, cellave&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">regridMethod</span>

        <span class="c1"># Setup regridder</span>
        <span class="k">if</span> <span class="n">regridTool</span><span class="o">==</span><span class="s1">&#39;regrid2&#39;</span><span class="p">:</span> <span class="c1"># Origignal CDMS regridder</span>

            <span class="n">keywords</span><span class="p">[</span><span class="s1">&#39;returnTuple&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span>
            <span class="kn">from</span> <span class="nn">regrid2</span> <span class="k">import</span> <span class="n">Horizontal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_regridder</span> <span class="o">=</span> <span class="n">Horizontal</span><span class="p">(</span><span class="n">fromgrid</span><span class="p">,</span> <span class="n">togrid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                   <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># ESMF or LIBCF regridders</span>

            <span class="c1"># Source mask</span>
            <span class="n">srcGridMask</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">float64</span>
            <span class="k">if</span> <span class="n">fromvar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># set the source mask if a mask is defined with the source data</span>
                <span class="k">if</span> <span class="n">N</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">fromvar</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="n">srcGridMask</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">avariable</span><span class="o">.</span><span class="n">getMinHorizontalMask</span><span class="p">(</span><span class="n">fromvar</span><span class="p">)</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">fromvar</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="o">!=</span><span class="s1">&#39;f&#39;</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">float64</span>
<span class="c1">#            if regridMethod==&#39;conservative&#39;:</span>
<span class="c1">#                # Hack for conservative</span>
<span class="c1">#                if srcGridMask is None:</span>
<span class="c1">#                    srcGridMask = N.zeros(fromgrid.shape, &#39;?&#39;)</span>
<span class="c1">#                srcGridMask[:, -1] = True</span>

            <span class="c1"># DstAreaFractions for cell</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span><span class="p">:</span>
                <span class="n">diag</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="p">{})</span>
                <span class="n">diag</span><span class="p">[</span><span class="s1">&#39;dstAreaFractions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">keywords</span><span class="p">[</span><span class="s1">&#39;diag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">diag</span>

            <span class="c1"># compute the interpolation weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_regridder</span> <span class="o">=</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">mvCdmsRegrid</span><span class="o">.</span><span class="n">CdmsRegrid</span><span class="p">(</span><span class="n">fromgrid</span><span class="p">,</span> <span class="n">togrid</span><span class="p">,</span>
                            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">,</span>
                            <span class="n">regridMethod</span> <span class="o">=</span> <span class="n">regridMethod</span><span class="p">,</span>
                            <span class="n">regridTool</span> <span class="o">=</span> <span class="n">regridTool</span><span class="p">,</span>
                            <span class="n">srcGridMask</span> <span class="o">=</span> <span class="n">srcGridMask</span><span class="p">,</span>
                            <span class="n">srcGridAreas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">dstGridMask</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">dstGridAreas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">keywords</span>

<div class="viewcode-block" id="CDATRegridder.regrid"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.CDATRegridder.regrid">[docs]</a>    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vari</span><span class="p">,</span> <span class="n">weidstfracs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">csvhack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regrid the variable</span>

<span class="sd">        :Params:</span>

<span class="sd">            - **vari**: Input variable.</span>
<span class="sd">            - **weidstfracs**, optional: Specify how to apply weights computed using</span>
<span class="sd">              destination fractions. Divide if &lt;0, else multiply. It is not used with</span>
<span class="sd">              linear and match methods.</span>
<span class="sd">            - **check_mask**, optional: Mask point using masked data (the algo</span>
<span class="sd">              interpolate the mask and check level 0.999). MUST BE IMPROVED!</span>
<span class="sd">              If None, mask is checked if tool!=&#39;regrid2&#39;</span>
<span class="sd">            - **csvhack**, optional: Hack to prevent a bug with conservative-like method</span>
<span class="sd">              of the ESMF regridder. Use it if you have strange result in the output</span>
<span class="sd">              most right longitude.</span>

<span class="sd">              .. warning:: The algo mask the must right longitude of input data before</span>
<span class="sd">                processing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Float type</span>
        <span class="k">if</span> <span class="n">vari</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="o">!=</span><span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="n">vari</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="c1"># Hack for conservative method bug</span>
        <span class="k">if</span> <span class="n">csvhack</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">==</span><span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">vari</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">vari</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mask</span>

        <span class="c1"># Regrid</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regridder</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Outputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">varo</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span><span class="p">:</span>
                <span class="n">wo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;diag&#39;</span><span class="p">][</span><span class="s1">&#39;dstAreaFractions&#39;</span><span class="p">],</span> <span class="n">varo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># regrid2 old regridder</span>
            <span class="n">varo</span><span class="p">,</span> <span class="n">wo</span> <span class="o">=</span> <span class="n">res</span>

        <span class="c1"># Working with destination fractions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getdstfracs</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">wo</span><span class="o">==</span><span class="mf">0.</span>

            <span class="c1"># Masking</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mskdstfracs</span><span class="p">:</span>
                <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">varo</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Scaling</span>
            <span class="k">if</span> <span class="n">weidstfracs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weidstfracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weidstfracs</span>
            <span class="k">if</span> <span class="n">weidstfracs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weidstfracs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">varo</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">wo</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wo</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">varo</span><span class="p">[:]</span> <span class="o">/=</span> <span class="n">wo</span>
            <span class="k">del</span> <span class="n">wo</span><span class="p">,</span> <span class="n">mask</span>

        <span class="c1"># Check mask</span>
        <span class="k">if</span> <span class="n">check_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tool</span> <span class="o">!=</span> <span class="s1">&#39;regrid2&#39;</span>
        <span class="k">if</span> <span class="n">check_mask</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">good</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
            <span class="n">goodo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">weidstfracs</span><span class="o">=</span><span class="n">weidstfracs</span><span class="p">,</span> <span class="n">check_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">csvhack</span><span class="o">=</span><span class="n">csvhack</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">good</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">goodo</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span> <span class="n">goodo</span> <span class="o">=</span> <span class="n">goodo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">goodo</span> <span class="o">=</span> <span class="n">goodo</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">varo</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">masked_where</span><span class="p">((</span><span class="n">goodo</span><span class="o">&lt;</span><span class="mf">0.9999</span><span class="p">),</span> <span class="n">varo</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="k">del</span> <span class="n">goodo</span>

        <span class="c1"># Finalize</span>
        <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">varo</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">regrid</span></div>



<div class="viewcode-block" id="CurvedInterpolator"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.CurvedInterpolator">[docs]</a><span class="k">class</span> <span class="nc">CurvedInterpolator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolator from a curved grid to random points or another grid</span>

<span class="sd">    :Params:</span>

<span class="sd">        - **fromgrid**: Input grid, or variable with a grid.</span>
<span class="sd">        - **topts**: Output coordinates or grid. It a tuple of coordinates, it is</span>
<span class="sd">          assumed that it refers to random points, and NOT a grid.</span>
<span class="sd">        - **g2g**, optional: Force the interpretation of ``topts`` as a grid or axes</span>
<span class="sd">          of a grid.</span>

<span class="sd">    :Examples:</span>

<span class="sd">        &gt;&gt;&gt; interpolator = CurvedInterpolator(ssti.getGrid(), (lono, lato)) # lono/lato 1D</span>
<span class="sd">        &gt;&gt;&gt; interpolator = CurvedInterpolator(ssti.getGrid(), grido) # grid</span>
<span class="sd">        &gt;&gt;&gt; ssto = interpolator(ssti)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">valid_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;dstwgt&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromgrid</span><span class="p">,</span> <span class="n">topts</span><span class="p">,</span> <span class="n">g2g</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Input coordinates</span>
        <span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span> <span class="o">=</span> <span class="n">get_xy</span><span class="p">(</span><span class="n">fromgrid</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shapei</span> <span class="o">=</span> <span class="n">xxi</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Output coordinates</span>
        <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">topts</span><span class="p">):</span> <span class="n">topts</span> <span class="o">=</span> <span class="n">topts</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g2g</span><span class="p">:</span>
            <span class="n">topts</span> <span class="o">=</span> <span class="n">get_grid</span><span class="p">(</span><span class="n">topts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isgrid</span><span class="p">(</span><span class="n">topts</span><span class="p">):</span>
            <span class="n">xxo</span><span class="p">,</span> <span class="n">yyo</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">topts</span><span class="o">.</span><span class="n">getLongitude</span><span class="p">(),</span> <span class="n">topts</span><span class="o">.</span><span class="n">getLatitude</span><span class="p">())</span>
            <span class="n">xo</span> <span class="o">=</span> <span class="n">xxo</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">yo</span> <span class="o">=</span> <span class="n">yyo</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grido</span> <span class="o">=</span> <span class="n">topts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shapeo</span> <span class="o">=</span> <span class="n">topts</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span> <span class="o">=</span> <span class="n">topts</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">yo</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Output axes must have the same length: </span><span class="si">%i</span><span class="s1">!=</span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xo</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">yo</span><span class="p">)))</span>
            <span class="n">xo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
            <span class="n">yo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yo</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grido</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shapeo</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Find relative positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q</span> <span class="o">=</span> <span class="n">_curv2rel_</span><span class="p">(</span><span class="n">xxi</span><span class="p">,</span> <span class="n">yyi</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">)</span>

<div class="viewcode-block" id="CurvedInterpolator.interp"><a class="viewcode-back" href="../../../../library/misc.grid.regridding.html#vacumm.bathy.bathy.CurvedInterpolator.interp">[docs]</a>    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vari</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate</span>

<span class="sd">        :Params:</span>

<span class="sd">            - **vari**: Variable to interpolate.</span>
<span class="sd">            - **method**, optional: Interpolation method. One of : %s.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="o">%</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">valid_methods</span><span class="p">)</span>
        <span class="c1"># Method and function</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">regrid2d_method_name</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VACUMMError</span><span class="p">(</span><span class="s1">&#39;Invalid interpolation method. Choose of: &#39;</span><span class="o">+</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">valid_methods</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;bilinear&#39;</span><span class="p">:</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;bilin&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">2dto1dc_reduc_&#39;</span><span class="o">%</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># Interpolate</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">get_fill_value</span><span class="p">()</span>
        <span class="n">zzi</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">asma</span><span class="p">()</span> <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span> <span class="k">else</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vari</span><span class="p">)</span>
        <span class="n">zzi</span> <span class="o">=</span> <span class="n">zzi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapei</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">mv</span><span class="p">)</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q</span><span class="p">,</span> <span class="n">zzi</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapeo</span><span class="p">)</span>
        <span class="n">zo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">zo</span><span class="p">)</span>
        <span class="n">varo</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">zo</span><span class="p">,</span> <span class="n">mv</span><span class="p">)</span>

        <span class="c1"># Finalize the cdms variable</span>
        <span class="k">if</span> <span class="n">cdms2</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">vari</span><span class="p">):</span>
            <span class="n">varo</span> <span class="o">=</span> <span class="n">MV2</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">varo</span><span class="p">)</span>
            <span class="n">cp_atts</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">varo</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vari</span><span class="o">.</span><span class="n">getAxisList</span><span class="p">()[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">varo</span><span class="o">.</span><span class="n">setAxis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grido</span><span class="p">:</span>
                <span class="n">set_grid</span><span class="p">(</span><span class="n">varo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grido</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">varo</span></div>

    <span class="n">regrid</span> <span class="o">=</span> <span class="fm">__call__</span> <span class="o">=</span> <span class="n">interp</span></div>

<span class="k">def</span> <span class="nf">_monotonise_</span><span class="p">(</span><span class="n">vari</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">targets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">targets</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">targets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">back</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vari</span>
        <span class="k">return</span> <span class="n">vari</span><span class="p">,</span> <span class="n">axes</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vari</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">targets</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">back</span><span class="p">:</span>
        <span class="n">oaxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">varo</span> <span class="o">=</span> <span class="n">vari</span>
    <span class="k">for</span> <span class="n">tg</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">tg</span><span class="p">]</span>

<span class="c1">#        # 2D case</span>
<span class="c1">#        #FIXME: add case when ax is 2d but not curvilinear like variable depths</span>
<span class="c1">#        ash = ax.shape</span>
<span class="c1">#        if len(ash)==2:</span>
<span class="c1">#            if min(ash)&gt;1:</span>
<span class="c1">#                continue</span>
<span class="c1">#            ax = ax.ravel()</span>

        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">subdim</span> <span class="o">=</span> <span class="p">(</span><span class="n">subdims</span><span class="p">[</span><span class="n">tg</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subdims</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">tg</span> <span class="ow">in</span> <span class="n">subdims</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">subdim</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">varo</span><span class="o">.</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
                <span class="n">sel</span><span class="p">[</span><span class="n">tg</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">varo</span> <span class="o">=</span> <span class="n">varo</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">back</span><span class="p">:</span>
                    <span class="n">sel</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
                    <span class="n">sel</span><span class="p">[</span><span class="n">subdim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">oaxes</span><span class="p">[</span><span class="n">tg</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel</span><span class="p">)]</span>
<span class="c1">#USE SUBDIM</span>

<span class="c1">#        ax.shape = ash</span>

    <span class="k">if</span> <span class="n">back</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">varo</span>
    <span class="k">return</span> <span class="n">varo</span><span class="p">,</span> <span class="n">oaxes</span>




<span class="c1">######################################################################</span>
<span class="c1">######################################################################</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Home</a>|&nbsp;</li>
        <li><a href="../../../../contents.html">Docs</a>|&nbsp;</li>
        <li><a href="../../../../user.faq.html">FAQ</a>|&nbsp;</li>
<!--         <li><a href="../../../../search.html">chercher</a>|&nbsp;</li> -->
        <li><a href="../../../../gallery.html">Gallery</a>|&nbsp;</li>
        <li><a href="https://forge.ifremer.fr/projects/vacumm">Forge</a>&nbsp; &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../vacumm.html" >vacumm</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2015, Actimar/IFREMER.
      Last updated on 21 Jan 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.3.
    </div>
  </body>
</html>